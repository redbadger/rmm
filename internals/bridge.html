<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FFI bridge - Crux: Cross-platform app development in Rust</title>


        <!-- Custom HTML head -->
        <script async defer src="https://beampipe.io/js/tracker.js" data-beampipe-domain="redbadger.github.io"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Crux: Cross-platform app development in Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/redbadger/crux/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/redbadger/crux/edit/master/docs/src/internals/bridge.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ffi-bridge"><a class="header" href="#ffi-bridge">FFI bridge</a></h1>
<p>In the previous chapter, we saw how the capability runtime facilitates the
orchestration of effect processing by the shell. We looked at the simpler
scenario where the shell was built in Rust. Now we'll extend this to the more
common scenario where the shell is written in a different language and the core
APIs are called over a Foreign Function Interface, passing events, requests and
responses back and forth, serialised as bytes.</p>
<h2 id="the-ffi-bridge"><a class="header" href="#the-ffi-bridge">The FFI bridge</a></h2>
<p>The FFI bridge has two key parts, the serialisation part converting from typed
effect requests to serializable types, and the FFI implementation itself,
facilitated by <a href="https://github.com/mozilla/uniffi-rs">UniFFI</a>.</p>
<p>The serialisation part is facilitated by the <code>Bridge</code>. It is a wrapper for the
<code>Core</code> with its own definition of <code>Request</code>. Its API is very similar to the
<code>Core</code> API - it has an identical set of methods, but their type signatures are
different.</p>
<p>For example, here is <code>Core::resolve</code></p>
<pre><code class="language-rust no_run noplayground">    pub fn resolve&lt;Op&gt;(&amp;self, request: &amp;mut Request&lt;Op&gt;, result: Op::Output) -&gt; Vec&lt;Ef&gt;
    where
        Op: Operation,</code></pre>
<p>and here's its counterpart, <code>Bridge::handle_response</code></p>
<pre><code class="language-rust no_run noplayground">    pub fn handle_response(&amp;self, id: u32, output: &amp;[u8]) -&gt; Vec&lt;u8&gt;</code></pre>
<p>where the core expects to be given a <code>Request&lt;Op&gt;</code> to resolve, the bridge
expects a <code>id</code> - a unique identifier of the request being resolved.</p>
<p>This makes sense - the <code>Request</code>s include callback closures working with the
capability runtime, they can't be easily serialised and sent back and forth
across the language boundary. Instead, the bridge "parks" them in a registry, to
be picked up later. Like in a theatre cloakroom, the registry returns a unique
number under which the request is stored.</p>
<p>The implementation of the serialization/deserialization process is slightly
complicated by the fact that Crux allows you to supply your own serializer and
deserializer should you need to, so the actual bridge implementation does not
work on bytes but on serializers. The <code>Bridge</code> type used in examples and all the
documentation is a default implementation, which uses bincode serialization,
which is also supported by the <a href="./typegen.html">type generation subsystem</a>.</p>
<p>We won't go into the detail of working with Serde and the
<a href="https://docs.rs/erased-serde/"><code>erased_serde</code></a> crate to make all the
serialization happen without leaking deserialization lifetimes out of the
bridge. You can read the implementation of <code>BridgeWithSerializer</code> if you're
interested in the gory details. For our purposes, the type definition will
suffice.</p>
<pre><code class="language-rust no_run noplayground">pub struct BridgeWithSerializer&lt;Eff, A&gt;
where
    Eff: Effect,
    A: App,
{
    core: Core&lt;Eff, A&gt;,
    registry: ResolveRegistry,
}</code></pre>
<p>The bridge holds an instance of the <code>Core</code> and a <code>ResolveRegistry</code> to store the
effect requests in.</p>
<p>The processing of the update loop is quite similar to the Core update loop:</p>
<ul>
<li>When a serialized event arrives, it is deserialized and passed to the <code>Core</code>'s
<code>process_event</code></li>
<li>When a request response arrives, its id is forwarded to the
<code>ResolveRegistry</code>'s <code>resume</code> method, and the <code>Core</code>'s <code>process</code> method is
called to run the capability runtime</li>
</ul>
<p>You may remember that both these calls return effect requests. The remaining
step is to store these in the registry, using the registry's <code>register</code> method,
exchanging the core <code>Request</code> for a bridge variant, which looks like this:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Serialize, Deserialize)]
pub struct Request&lt;Eff&gt;
where
    Eff: Serialize,
{
    pub id: EffectId,
    pub effect: Eff,
}</code></pre>
<p>Unlike the core request, this does not include any closures and is fully
serializable.</p>
<h2 id="resolveregistry"><a class="header" href="#resolveregistry">ResolveRegistry</a></h2>
<p>It is worth pausing for a second on the resolve registry. There is one tricky
problem to solve here - storing the generic <code>Request</code>s in a single store. We get
around this by making the <code>register</code> method generic and asking the effect to
"serialize" itself.</p>
<pre><code class="language-rust no_run noplayground">    pub fn register&lt;Eff&gt;(&amp;self, effect: Eff) -&gt; Request&lt;Eff::Ffi&gt;
    where
        Eff: Effect,
    {
        let (effect, resolve) = effect.serialize();

        let id = self
            .0
            .lock()
            .expect("Registry Mutex poisoned.")
            .insert(resolve);

        Request {
            id: EffectId(id.try_into().expect("EffectId overflow")),
            effect,
        }
    }</code></pre>
<p>this is named based on our intent, not really based on what actually happens.
The method comes from an <code>Effect</code> trait:</p>
<pre><code class="language-rust no_run noplayground">pub trait Effect: Send + 'static {
    /// Ffi is an enum with variants corresponding to the Effect variants
    /// but instead of carrying a `Request&lt;Op&gt;` they carry the `Op` directly
    type Ffi: Serialize;

    /// Converts the `Effect` into its FFI counterpart and returns it alongside
    /// a deserializing version of the resolve callback for the request that the
    /// original `Effect` was carrying.
    ///
    /// You should not need to call this method directly. It is called by
    /// the [`Bridge`](crate::bridge::Bridge)
    fn serialize(self) -&gt; (Self::Ffi, ResolveSerialized);
}</code></pre>
<p>Like the <code>Effect</code> type which implements this trait, the implementation is macro
generated, based on the Capabilities used by your application. We will look at
how this works in the <a href="./effect.html"><code>Effect type</code></a> chapter.</p>
<p>The type signature of the method gives us a hint though - it converts the normal
<code>Effect</code> into a serializable counterpart, alongside something with a
<code>ResolveSerialized</code> type. This is stored in the registry under an id, and the effect and the id are returned as the bridge version
of a <code>Request</code>.</p>
<p>The definition of the <code>ResolveSerialized</code> type is a little bit convoluted:</p>
<pre><code class="language-rust no_run noplayground">type ResolveOnceSerialized = Box&lt;dyn FnOnce(&amp;mut dyn erased_serde::Deserializer) + Send&gt;;
type ResolveManySerialized =
    Box&lt;dyn FnMut(&amp;mut dyn erased_serde::Deserializer) -&gt; Result&lt;(), ()&gt; + Send&gt;;

/// A deserializing version of Resolve
///
/// ResolveSerialized is a separate type because lifetime elision doesn't work
/// through generic type arguments. We can't create a ResolveRegistry of
/// Resolve&lt;&amp;[u8]&gt; without specifying an explicit lifetime.
/// If you see a better way around this, please open a PR.
pub enum ResolveSerialized {
    Never,
    Once(ResolveOnceSerialized),
    Many(ResolveManySerialized),
}</code></pre>
<p>but the gist of it is that it is a mirror of the <code>Resolve</code> type we already know,
except it takes a Deserializer. More about this serialization trickery in the
next chapter.</p>
<h2 id="ffi-interface"><a class="header" href="#ffi-interface">FFI interface</a></h2>
<p>The final piece of the puzzle is the FFI interface itself. All it does is expose
the bridge API we've seen above.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note"></a>
</div>
<div>
<p>You will see that this part, alongside the type generation, is a fairly
complicated constellation of various existing tools and libraries, which has
a number of rough edges. It is likely that we will explore replacing this
part of Crux with a tailor made FFI bridge in the future. If/when we do, we will
do our best to provide a smooth migration path.</p>
</div>
</div>
<p>Here's a typical app's shared crate <code>src/lib.rs</code> file:</p>
<pre><code class="language-rust no_run noplayground">pub mod app;

use lazy_static::lazy_static;
use wasm_bindgen::prelude::wasm_bindgen;

pub use crux_core::{bridge::Bridge, Core, Request};

pub use app::*;

// TODO hide this plumbing

uniffi::include_scaffolding!("shared");

lazy_static! {
    static ref CORE: Bridge&lt;Effect, App&gt; = Bridge::new(Core::new());
}

#[wasm_bindgen]
pub fn process_event(data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    CORE.process_event(data)
}

#[wasm_bindgen]
pub fn handle_response(id: u32, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    CORE.handle_response(id, data)
}

#[wasm_bindgen]
pub fn view() -&gt; Vec&lt;u8&gt; {
    CORE.view()
}</code></pre>
<p>Ignore the TODO, we will get to that eventually, I promise. There are two forms
of FFI going on - the <code>wasm_bindgen</code> annotations on the three functions,
exposing them when built as webassembly, and also the line saying</p>
<pre><code class="language-rust no_run noplayground">uniffi::include_scaffolding!("shared");</code></pre>
<p>which refers to the <code>shared.udl</code> file in the same folder</p>
<pre><code>namespace shared {
  bytes process_event([ByRef] bytes msg);
  bytes handle_response(u32 id, [ByRef] bytes res);
  bytes view();
};
</code></pre>
<p>This is UniFFI's interface definition used to generate the scaffolding for the
FFI interface - both the externally callable functions in the <code>shared</code> library,
and their counterparts in the "foreign" languages (like Swift or Kotlin).</p>
<p>The scaffolding is built in the <code>build.rs</code> script of the crate</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    uniffi::generate_scaffolding("./src/shared.udl").unwrap();
}</code></pre>
<p>The foreign language code is built by an additional binary target for the same
crate, in <code>src/bin/uniffi-bindgen.rs</code></p>
<pre><code class="language-rust no_run noplayground">fn main() {
    uniffi::uniffi_bindgen_main()
}</code></pre>
<p>this builds a CLI which can be used as part of the build process for clients of
the library to generate the code.</p>
<p>The details of this process are well documented
<a href="https://mozilla.github.io/uniffi-rs/Getting_started.html">in UniFFI's tutorial</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../internals/runtime.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../internals/effect.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../internals/runtime.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../internals/effect.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
