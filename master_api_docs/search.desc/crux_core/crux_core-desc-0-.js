searchState.loadedDescShard("crux_core", 0, "Cross-platform app development in Rust\nImplement <code>App</code> on your type to make it into a Crux app. Use …\nCapabilities, typically a <code>struct</code>, lists the capabilities …\nThe Crux core. Create an instance of this type with your …\nImplemented automatically with the Effect macro from …\nEvent, typically an <code>enum</code>, defines the actions that can be …\nFfi is an enum with variants corresponding to the Effect …\nModel, typically a <code>struct</code> defines the internal state of …\nRequest represents an effect request from the core to the …\nViewModel, typically a <code>struct</code> describes the user interface …\nPanics if the pattern doesn’t match an <code>Effect</code> from the …\nCapabilities provide a user-friendly API to request …\nA capability which can spawn tasks which orchestrate …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an instance of the Crux core to start a Crux …\nRun the app’s <code>update</code> function with a given <code>event</code>, …\nBuilt-in capability used to notify the Shell that a UI …\nResolve an effect <code>request</code> for operation <code>Op</code> with the …\nConverts the <code>Effect</code> into its FFI counterpart and returns …\nSerialize this effect request using <code>effect</code> as a constructor\nTesting support for unit testing Crux apps.\nUpdate method defines the transition from one <code>model</code> state …\nView method is used by the Shell to request the current …\nGet the current state of the app’s view model.\nBridge is a core wrapper presenting the same interface as …\nA bridge with a user supplied serializer\nRequest for a side-effect passed from the Core to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReceive a response to a capability request from the shell.\nReceive a response to a capability request from the shell.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new Bridge using the provided <code>core</code>.\nReceive an event from the shell.\nReceive an event from the shell.\nGet the current state of the app’s view model …\nGet the current state of the app’s view model …\nImplement the <code>Capability</code> trait for your capability. This …\nAn interface for capabilities to interact with the app and …\nA type that can be used as a capability operation, but …\nOperation trait links together input and output of a …\n<code>Output</code> assigns the type this request results in.\nInitial version of capability Context which has not yet …\nAllows Crux to construct app’s set of required …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransform the CapabilityContext into one which uses the …\nSend an effect request to the shell in a fire and forget …\nSend an effect request to the shell, expecting an output. …\nSpawn a task to do the asynchronous work. Within the task, …\nSpecialize the CapabilityContext to a specific capability, …\nSend an effect request to the shell, expecting a stream of …\nSend an event to the app. The event will be processed on …\nCompose capability can be used to orchestrate effects into …\nA restricted context given to the closure passed to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSpawn a task which orchestrates across other capabilities.\nUpdate the app with an event. This forwards to …\nUse an instance of <code>Render</code> to notify the Shell that it …\nThe single operation <code>Render</code> implements.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCall <code>render</code> from <code>App::update</code> to signal to the Shell that …\nAppTester is a simplified execution environment for Crux …\nUpdate test helper holds the result of running an app …\nAssert that the update contains no effects or events\nEffects requested from the update run\nEvents dispatched from the update run\nAssert that the update contains exactly one effect and …\nAssert that the update contains exactly one event and zero …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>AppTester</code> instance for an existing app instance. …\nResolve an effect <code>request</code> from previous update with an …\nResolve an effect <code>request</code> from previous update, then run …\nTake effects matching the <code>predicate</code> out of the <code>Update</code> and …\nTake all of the effects out of the <code>Update</code> and split them …\nRun the app’s <code>update</code> function with an event and a model …\nRun the app’s <code>view</code> function with a model state")