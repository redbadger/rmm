<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Crux: Cross-platform app development in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script async defer src="https://beampipe.io/js/tracker.js" data-beampipe-domain="redbadger.github.io"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Crux: Cross-platform app development in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/redbadger/crux/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Crux is a framework for building cross-platform applications
with better testability, higher code and behavior reuse, better safety,
security, and more joy from better tools.</p>
<p>It splits the application into two distinct parts, a Core built in Rust, which
drives as much of the business logic as possible, and a Shell, built in the
platform native language (Swift, Kotlin, TypeScript), which provides all
interfaces with the external world, including the human user, and acts as a
platform on which the core runs.</p>
<p><img src="./crux.png" alt="Crux" /></p>
<p>The interface between the two is a native FFI (Foreign Function Interface) with
cross-language type checking and message passing semantics, where simple data
structures are passed across the boundary.</p>
<div id="admonition-get-to-know-crux" class="admonition admonish-note" role="note" aria-labelledby="admonition-get-to-know-crux-title">
<div class="admonition-title">
<div id="admonition-get-to-know-crux-title">
<p>Get to know Crux</p>
</div>
<a class="admonition-anchor-link" href="overview.html#admonition-get-to-know-crux"></a>
</div>
<div>
<p>To get playing with Crux quickly, follow the <a href="./getting_started/core.html">Getting Started</a> steps. If you prefer to read more about how apps are built in Crux first, read the <a href="./guide/hello_world.html">Development Guide</a>. And if you'd like to know what possessed us to try this in the first place, read about our <a href="./motivation.html">Motivation</a>.</p>
<p>There are two places to find API documentation: the latest published version on docs.rs, and we also have the very latest master docs if you too like to live dangerously.</p>
<ul>
<li><strong>crux_core</strong> - the main Crux crate: <a href="https://docs.rs/crux_core/latest/crux_core/">latest release</a> | <a href="https://redbadger.github.io/crux/master_api_docs/crux_core/">latest master</a></li>
<li><strong>crux_http</strong> - HTTP client capability: <a href="https://docs.rs/crux_http/latest/crux_http/">latest release</a> | <a href="https://redbadger.github.io/crux/master_api_docs/crux_http/">latest master</a></li>
</ul>
<p>Crux is open source on <a href="https://github.com/redbadger/crux">Github</a>. A good way to learn Crux is to explore the code, play with the <a href="https://github.com/redbadger/crux/tree/master/examples">examples</a>, and raise issues or pull requests. We'd love you to get involved.</p>
<p>You can also join the friendly conversation on our <a href="https://crux-community.zulipchat.com">Zulip channel</a>.</p>
</div>
</div>
<h2 id="design-overview"><a class="header" href="#design-overview">Design overview</a></h2>
<p><img src="./architecture.svg" alt="Logical architecture" /></p>
<p>The architecture is event-driven, based on
<a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>. The Core
holds the majority of state, which is updated in response to events happening in
the Shell. The interface between the Core and the Shell is message-based.</p>
<p>The user interface layer is built natively, with modern declarative UI
frameworks such as Swift UI, Jetpack Compose and React/Vue or a WASM based
framework on the web. The UI layer is as thin as it can be, and all other
application logic is performed by the shared Core. The one restriction is that
the Core is side–effect free. This is both a technical requirement (to be able
to target WebAssembly), and an intentional design goal, to separate logic from
effects and make them both easier to test in isolation.</p>
<p>The core requests side-effects from the Shell through common
<a href="./guide/capabilities.html">capabilities</a>. The basic concept is that instead of
<em>doing</em> the asynchronous work, the core <em>describes</em> the intent for the work with
data, and passes this to the Shell to be performed. The Shell performs the work,
and returns the outcomes back to the Core. This approach is inspired by
<a href="https://elm-lang.org/">Elm</a>, and similar to how other purely functional
languages deal with effects and I/O (e.g. the IO monad in Haskell). It is also
similar to how iterators work in Rust.</p>
<p>The Core exports types for the messages it can understand. The Shell can call
the Core and pass one of the messages. In return, it receives a set of
side-effect requests to perform. When the work is completed, the Shell sends the
result back into the Core, which responds with further requests if necessary.</p>
<p>Updating the user interface is considered one of the side-effects the Core can
request. The entire interface is strongly typed and breaking changes in the core
will result in build failures in the Shell.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>We set out to find a better way of building apps
across platforms. You can read more <a href="./motivation.html">about our motivation</a>. The
overall goals of Crux are to:</p>
<ul>
<li>Build the majority of the application code once, in Rust</li>
<li>Encapsulate the <em>behavior</em> of the app in the Core for reuse</li>
<li>Follow the Ports and Adapters pattern, also known as
<a href="https://alistair.cockburn.us/hexagonal-architecture/">Hexagonal Architecture</a>
to facilitate pushing side-effects to the edge, making behavior easy to test</li>
<li>Separate the behavior from the look and feel and interaction design</li>
<li>Use the native UI tool kits to create user experience that is the best fit for
a given platform</li>
</ul>
<h2 id="path-to-10"><a class="header" href="#path-to-10">Path to 1.0</a></h2>
<p>Crux is used in production apps today, and we consider it production ready. However, we still have a number of things to work on to call it 1.0, with a stable API, and other things one would expect from a mature framework.</p>
<p>Below is a list of some of the things we know we want to do before 1.0:</p>
<ul>
<li>Improved documentation, code examples, and example apps for newcomers</li>
<li>Improved onboarding experience, with less boilerplate code that end users have
to deal with</li>
<li>Better FFI code generation to enable support for more languages (e.g. C#, Dart, even C++...)
and in trurn more Shells (e.g. .NET, Flutter) which will also enable Desktop apps for Windows</li>
<li>Revised capabilities and effects to allow for better, more natural
<a href="./guide/composing.html">app composition</a> in larger apps, for composing capabilities,
and generally for a more ergonomic effect API overall</li>
</ul>
<p>Until then, we hope you will work with us on the rough edges, and adapt to the necessary
API updates as we evolve. We strive to minimise the impact of changes as much as we can, but before 1.0, some breaking changes will be unavoidable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>We set out to prove this approach to building apps largely because we've seen
the drawbacks of all the other approaches in real life, and thought "there must
be a better way". The two major available approaches to building the same
application for iOS and Android are:</p>
<ol>
<li>Build a native app for each platform, effectively doing the work twice.</li>
<li>Use React Native or Flutter to build the application once<sup class="footnote-reference"><a href="#once">1</a></sup> and produce
native looking and feeling apps which behave nearly identically.</li>
</ol>
<p>The drawback of the first approach is doing the work twice. In order to build
every feature for iOS and Android at the same time, you need twice the number of
people, either people who happily do Swift and Kotlin (and they are very rare),
or more likely a set of iOS engineers and another set of Android engineers. This
typically leads to forming two separate, platform-focused teams. We have
witnessed situations first-hand, where those teams struggle with the same design
problems, and despite one encountering and solving the problem first, the other
one can learn nothing from their experience (and that's <em>despite</em> long design
discussions).</p>
<p>We think such experiences with the platform native approach are common, and the
reason why people look to React Native and Flutter. The issues with React Native
are two fold</p>
<ul>
<li>Only <em>mostly</em> native user interface</li>
<li>In the case of React Native, the JavaScript ecosystem tooling disaster</li>
</ul>
<p>React Native effectively takes over, and works hard to insulate the engineer
from the native platform underneath and pretend it doesn't really exist, but of
course, inevitably, it does and the user interface ends up being built in a
combination of 90% JavaScript/TypeScript and 10% Kotlin/Swift. This was still a
major win when React Native was first introduced, because the platform native UI
toolkits were imperative, following a version of MVC architecture, and generally
made it quite difficult to get UI state management right. React on the other
hand is declarative, leaving much less space for errors stemming from the UI
getting into an undefined state. This benefit was clearly recognised by iOS and
Android, and both introduced their own declarative UI toolkit - Swift UI and
Jetpack Compose. Both of them are quite good, matching that particular advantage
of React Native, and leaving only building things once (in theory). But in
exchange, they have to be written in JavaScript (and adjacent tools and
languages).</p>
<p>The main issue with the JavaScript ecosystem is that it's built on sand. The
underlying language is quite loose and has a
<a href="https://www.destroyallsoftware.com/talks/wat">lot of inconsistencies</a>. It came
with no package manager originally, now <a href="https://www.npmjs.com/">it</a>
<a href="https://yarnpkg.com/">has</a> <a href="https://pnpm.io/">three</a>. To serve code to the
browser, it gets bundled, and the list of bundlers is too long to include here.
<a href="https://webpack.js.org/">Webpack</a>, the most popular one, is famously difficult
to configure. JavaScript was built as a dynamic language which leads to a lot of
basic human errors, which are made while writing the code, only being discovered
when running the code. Static type systems aim to solve that problem and
<a href="https://www.typescriptlang.org/">TypeScript</a> adds this onto JavaScript, but the
types only go so far (until they hit an <code>any</code> type, or dependencies with no type
definitions), and they disappear at runtime.</p>
<p>In short, upgrading JavaScript to something modern takes a lot of tooling.
Getting all this tooling set up and ready to build things is an all day job, and
so more tooling, like <a href="https://nextjs.org/">Next.js</a> has popped up providing
this configuration in a box, batteries included. Perhaps the final admission of
this problem is the recent <a href="https://biomejs.dev/blog/annoucing-biome/">Biome</a>
toolchain (formerly the Rome project), attempting to bring all the various tools
under one roof (and Biome itself is built in Rust...).</p>
<p>It's no wonder that even a working setup of all the tooling has sharp edges, and
cannot afford to be nearly as strict as tooling designed with strictness in
mind, such as Rust's. The heart of the problem is that computers are strict and
precise instruments, and humans are sloppy creatures. With enough humans (more
than 10, being generous) and no additional help, the resulting code will be
sloppy, full of unhandled edge cases, undefined behaviour being relied on,
circular dependencies preventing testing in isolation, etc. (and yes, these are
not hypotheticals).</p>
<p>Contrast that with Rust, which is as strict as it gets, and generally backs up
the claim that if it compiles it will work (and if you struggle to get it past
the compiler, it's probably a bad idea). The tooling and package management is
built in with <code>cargo</code>. There are fewer decisions to make when setting up a Rust
project.</p>
<p>In short, we think the JS ecosystem has jumped the shark, the "complexity
toothpaste" is out of the tube, and it's time to stop. But there's no real
viable alternative. Crux is our attempt to provide one.</p>
<hr />
<div class="footnote-definition" id="once"><sup class="footnote-definition-label">1</sup>
<p>In reality it's more like 1.4x effort build the same app for two platforms.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-core-and-types"><a class="header" href="#shared-core-and-types">Shared core and types</a></h1>
<p>These are the steps to set up the two crates forming the shared core – the core
itself, and the shared types crate which does type generation for the foreign
languages.</p>
<div id="admonition-sharp-edge" class="admonition admonish-warning" role="note" aria-labelledby="admonition-sharp-edge-title">
<div class="admonition-title">
<div id="admonition-sharp-edge-title">
<p>Sharp edge</p>
</div>
<a class="admonition-anchor-link" href="getting_started/core.html#admonition-sharp-edge"></a>
</div>
<div>
<p>Most of these steps are going to be automated in future tooling, and published as crates. For now the set up is effectively a copy &amp; paste from one of the <a href="https://github.com/redbadger/crux/tree/master/examples">example projects</a>.</p>
</div>
</div>
<h2 id="install-the-tools"><a class="header" href="#install-the-tools">Install the tools</a></h2>
<p>This is an example of a
<a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file"><code>rust-toolchain.toml</code></a>
file, which you can add at the root of your repo. It should ensure that the
correct rust channel and compile targets are installed automatically for you
when you use any rust tooling within the repo.</p>
<!--- includes fail when indented see https://github.com/rust-lang/mdBook/pull/1718 --->
<pre><code class="language-toml">[toolchain]
channel = "stable"
components = ["rustfmt", "rustc-dev"]
targets = [
  "aarch64-apple-darwin",
  "aarch64-apple-ios",
  "aarch64-apple-ios-sim",
  "aarch64-linux-android",
  "wasm32-unknown-unknown",
  "x86_64-apple-ios"
]
profile = "minimal"
</code></pre>
<h2 id="create-the-core-crate"><a class="header" href="#create-the-core-crate">Create the core crate</a></h2>
<h3 id="the-shared-library"><a class="header" href="#the-shared-library">The shared library</a></h3>
<p>The first library to create is the one that will be shared across all platforms,
containing the <em>behavior</em> of the app. You can call it whatever you like, but we
have chosen the name <code>shared</code> here. You can create the shared rust library, like
this:</p>
<pre><code class="language-sh">cargo new --lib shared
</code></pre>
<h3 id="the-workspace-and-library-manifests"><a class="header" href="#the-workspace-and-library-manifests">The workspace and library manifests</a></h3>
<p>We'll be adding a bunch of other folders into the monorepo, so we are choosing
to use Cargo Workspaces. Edit the workspace <code>/Cargo.toml</code> file, at the monorepo
root, to add the new library to our workspace. It should look something like
this:</p>
<pre><code class="language-toml">[workspace]
members = ["shared"]
resolver = "1"

[workspace.package]
authors = ["Red Badger Consulting Limited"]
edition = "2021"
repository = "https://github.com/redbadger/crux/"
license = "Apache-2.0"
keywords = ["crux", "crux_core", "cross-platform-ui", "ffi", "wasm"]
rust-version = "1.66"

[workspace.dependencies]
anyhow = "1.0.86"
crux_core = "0.8"
serde = "1.0.203"
</code></pre>
<p>The library's manifest, at <code>/shared/Cargo.toml</code>, should look something like the
following, but there are a few things to note:</p>
<ul>
<li>the <code>crate-type</code>
<ul>
<li><code>lib</code> is the default rust library when linking into a rust binary, e.g. in
the <code>web-yew</code>, or <code>cli</code>, variant</li>
<li><code>staticlib</code> is a static library (<code>libshared.a</code>) for including in the Swift
iOS app variant</li>
<li><code>cdylib</code> is a C-ABI dynamic library (<code>libshared.so</code>) for use with JNA when
included in the Kotlin Android app variant</li>
</ul>
</li>
<li>we need to declare a feature called <code>typegen</code> that depends on the feature with
the same name in the <code>crux_core</code> crate. This is used by this crate's sister
library (often called <code>shared_types</code>) that will generate types for use across
the FFI boundary (see the section below on generating shared types).</li>
<li>the uniffi dependencies and <code>uniffi-bindgen</code> target should make sense after
you read the next section</li>
</ul>
<pre><code class="language-toml">[package]
name = "shared"
version = "0.1.0"
edition = "2021"
rust-version = "1.66"

[lib]
crate-type = ["lib", "staticlib", "cdylib"]
name = "shared"

[features]
typegen = ["crux_core/typegen"]

[dependencies]
crux_core.workspace = true
serde = { workspace = true, features = ["derive"] }
lazy_static = "1.5.0"
uniffi = "0.28.2"
wasm-bindgen = "0.2.95"

[target.uniffi-bindgen.dependencies]
uniffi = { version = "0.28.2", features = ["cli"] }

[build-dependencies]
uniffi = { version = "0.28.2", features = ["build"] }
</code></pre>
<h3 id="ffi-bindings"><a class="header" href="#ffi-bindings">FFI bindings</a></h3>
<p>Crux uses Mozilla's <a href="https://mozilla.github.io/uniffi-rs/">Uniffi</a> to generate
the FFI bindings for iOS and Android.</p>
<h4 id="generating-the-uniffi-bindgen-cli-tool"><a class="header" href="#generating-the-uniffi-bindgen-cli-tool">Generating the <code>uniffi-bindgen</code> CLI tool</a></h4>
<p>Since version <code>0.23.0</code> of Uniffi, we need to also generate the
binary that generates these bindings. This avoids the possibility of getting a
version mismatch between a separately installed binary and the crate's Uniffi
version. You can read more about it
<a href="https://mozilla.github.io/uniffi-rs/tutorial/foreign_language_bindings.html">here</a>.</p>
<p>Generating the binary is simple, we just add the following to our crate, in a
file called <code>/shared/src/bin/uniffi-bindgen.rs</code>.</p>
<pre><code class="language-rust ignore">fn main() {
    uniffi::uniffi_bindgen_main()
}</code></pre>
<p>And then we can build it with cargo.</p>
<pre><code class="language-sh">cargo run -p shared --bin uniffi-bindgen

# or

cargo build
./target/debug/uniffi-bindgen
</code></pre>
<p>The <code>uniffi-bindgen</code> executable will be used during the build in XCode and in
Android Studio (see the following pages).</p>
<h4 id="the-interface-definitions"><a class="header" href="#the-interface-definitions">The interface definitions</a></h4>
<p>We will need an interface definition file for the FFI bindings. Uniffi has its
own file format (similar to WebIDL) that has a <code>.udl</code> extension. You can create
one at <code>/shared/src/shared.udl</code>, like this:</p>
<pre><code class="language-txt">namespace shared {
  bytes process_event([ByRef] bytes msg);
  bytes handle_response(u32 id, [ByRef] bytes res);
  bytes view();
};
</code></pre>
<p>There are also a few additional parameters to tell Uniffi how to create bindings
for Kotlin and Swift. They live in the file <code>/shared/uniffi.toml</code>, like this
(feel free to adjust accordingly):</p>
<pre><code class="language-toml">[bindings.kotlin]
package_name = "com.example.simple_counter.shared"
cdylib_name = "shared"

[bindings.swift]
cdylib_name = "shared_ffi"
omit_argument_labels = true
</code></pre>
<p>Finally, we need a <code>build.rs</code> file in the root of the crate
(<code>/shared/build.rs</code>), to generate the bindings:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    uniffi::generate_scaffolding("./src/shared.udl").unwrap();
}</code></pre>
<h3 id="scaffolding"><a class="header" href="#scaffolding">Scaffolding</a></h3>
<p>Soon we will have macros and/or code-gen to help with this, but for now, we need
some scaffolding in <code>/shared/src/lib.rs</code>. You'll notice that we are re-exporting
the <code>Request</code> type and the capabilities we want to use in our native Shells, as
well as our public types from the shared library.</p>
<pre><code class="language-rust no_run noplayground">pub mod app;

use lazy_static::lazy_static;
use wasm_bindgen::prelude::wasm_bindgen;

pub use crux_core::{bridge::Bridge, Core, Request};

pub use app::*;

// TODO hide this plumbing

uniffi::include_scaffolding!("shared");

lazy_static! {
    static ref CORE: Bridge&lt;Effect, Counter&gt; = Bridge::new(Core::new());
}

#[wasm_bindgen]
pub fn process_event(data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    CORE.process_event(data)
}

#[wasm_bindgen]
pub fn handle_response(id: u32, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    CORE.handle_response(id, data)
}

#[wasm_bindgen]
pub fn view() -&gt; Vec&lt;u8&gt; {
    CORE.view()
}</code></pre>
<h3 id="the-app"><a class="header" href="#the-app">The app</a></h3>
<p>Now we are in a position to create a basic app in <code>/shared/src/app.rs</code>. This is
from the
<a href="https://github.com/redbadger/crux/blob/master/examples/simple_counter/shared/src/counter.rs">simple Counter example</a>
(which also has tests, although we're not showing them here):</p>
<pre><code class="language-rust no_run noplayground">use crux_core::{render::Render, App};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum Event {
    Increment,
    Decrement,
    Reset,
}

#[derive(Default)]
pub struct Model {
    count: isize,
}

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct ViewModel {
    pub count: String,
}

#[cfg_attr(feature = "typegen", derive(crux_core::macros::Export))]
#[derive(crux_core::macros::Effect)]
pub struct Capabilities {
    render: Render&lt;Event&gt;,
}

#[derive(Default)]
pub struct Counter;

impl App for Counter {
    type Event = Event;
    type Model = Model;
    type ViewModel = ViewModel;
    type Capabilities = Capabilities;

    fn update(&amp;self, event: Self::Event, model: &amp;mut Self::Model, caps: &amp;Self::Capabilities) {
        match event {
            Event::Increment =&gt; model.count += 1,
            Event::Decrement =&gt; model.count -= 1,
            Event::Reset =&gt; model.count = 0,
        };

        caps.render.render();
    }

    fn view(&amp;self, model: &amp;Self::Model) -&gt; Self::ViewModel {
        ViewModel {
            count: format!("Count is: {}", model.count),
        }
    }
}</code></pre>
<p>Make sure everything builds OK</p>
<pre><code class="language-sh">cargo build
</code></pre>
<h2 id="create-the-shared-types-crate"><a class="header" href="#create-the-shared-types-crate">Create the shared types crate</a></h2>
<p>This crate serves as the container for type generation for the foreign
languages.</p>
<p>Work is being done to remove the need for this crate, but for now, it is needed
in order to drive the generation of the types that cross the FFI boundary.</p>
<ul>
<li>
<p>Copy over the
<a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter/shared_types">shared_types</a>
folder from the simple_counter example.</p>
</li>
<li>
<p>Add the shared types crate to <code>workspace.members</code> in the <code>/Cargo.toml</code> file at the
monorepo root.</p>
</li>
<li>
<p>Edit the <code>build.rs</code> file and make sure that your app type is registered. In
our example, the app type is <code>Counter</code>, so make sure you include this
statement in your <code>build.rs</code></p>
</li>
</ul>
<pre><code class="language-rust ignore"> gen.register_app::&lt;Counter&gt;()?;</code></pre>
<p>The <code>build.rs</code> file should now look like this:</p>
<pre><code class="language-rust no_run noplayground">use crux_core::typegen::TypeGen;
use shared::Counter;
use std::path::PathBuf;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    println!("cargo:rerun-if-changed=../shared");

    let mut gen = TypeGen::new();

    gen.register_app::&lt;Counter&gt;()?;

    let output_root = PathBuf::from("./generated");

    gen.swift("SharedTypes", output_root.join("swift"))?;

    gen.java(
        "com.example.simple_counter.shared_types",
        output_root.join("java"),
    )?;

    gen.typescript("shared_types", output_root.join("typescript"))?;

    Ok(())
}</code></pre>
<p>If you are using the latest versions of the
<code>crux_http</code> (&gt;= <code>v0.10.0</code>), <code>crux_kv</code> (&gt;= <code>v0.5.0</code>) or <code>crux_time</code> (&gt;= <code>v0.5.0</code>)
capabilities, you will need to add a build dependency to the capability crate,
with the <code>typegen</code> feature enabled — so your <code>Cargo.toml</code> file may end up looking something like this
(from the <a href="https://github.com/redbadger/crux/tree/master/examples/cat_facts"><code>cat_facts</code></a> example):</p>
<pre><code class="language-toml">[package]
name = "shared_types"
version = "0.1.0"
authors.workspace = true
repository.workspace = true
edition.workspace = true
license.workspace = true
keywords.workspace = true
rust-version.workspace = true

[dependencies]

[build-dependencies]
anyhow.workspace = true
crux_core = { workspace = true, features = ["typegen"] }
crux_http = { workspace = true, features = ["typegen"] }
crux_kv = { workspace = true, features = ["typegen"] }
crux_time = { workspace = true, features = ["typegen"] }
shared = { path = "../shared", features = ["typegen"] }
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/core.html#admonition-tip"></a>
</div>
<div>
<p>Due to a current limitation with the reflection library,
you may need to manually register nested enum types in your <code>build.rs</code> file.
(see <a href="https://github.com/zefchain/serde-reflection/tree/main/serde-reflection#supported-features">https://github.com/zefchain/serde-reflection/tree/main/serde-reflection#supported-features</a>)</p>
<p><em>Note, you don't have to do this for the latest versions of the
<code>crux_http</code> (&gt;= <code>v0.10.0</code>), <code>crux_kv</code> (&gt;= <code>v0.5.0</code>) or <code>crux_time</code> (&gt;= <code>v0.5.0</code>)
capabilities, which now do this registration for you — although you will need to add
a build dependency to the capability crate, with the <code>typegen</code> feature enabled.</em></p>
<p>If you <em>do</em> end up needing to register a type manually (you should get a helpful error to tell you this),
you can use the <code>register_type</code> method (e.g. <code>gen.register_type::&lt;TextCursor&gt;()?;</code>) as
shown in this
<a href="https://github.com/redbadger/crux/blob/master/examples/notes/shared_types/build.rs"><code>build.rs</code></a>
file from the <code>shared_types</code> crate of the
<a href="https://github.com/redbadger/crux/tree/master/examples/notes">notes example</a>:</p>
<pre><code class="language-rust ignore">use crux_core::typegen::TypeGen;
use shared::{NoteEditor, TextCursor};
use std::path::PathBuf;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    println!("cargo:rerun-if-changed=../shared");

    let mut gen = TypeGen::new();

    gen.register_app::&lt;NoteEditor&gt;()?;

    // Note: currently required as we can't find enums inside enums, see:
    // https://github.com/zefchain/serde-reflection/tree/main/serde-reflection#supported-features
    gen.register_type::&lt;TextCursor&gt;()?;

    let output_root = PathBuf::from("./generated");

    gen.swift("SharedTypes", output_root.join("swift"))?;

    // TODO these are for later
    //
    // gen.java("com.example.counter.shared_types", output_root.join("java"))?;

    gen.typescript("shared_types", output_root.join("typescript"))?;

    Ok(())
}</code></pre>
</div>
</div>
<h3 id="building-your-app"><a class="header" href="#building-your-app">Building your app</a></h3>
<p>Make sure everything builds and foreign types get generated into the
<code>generated</code> folder.</p>
<p>(If you're generating TypeScript, you may need <code>pnpm</code> to be installed and in your <code>$PATH</code>.)</p>
<pre><code class="language-sh">cargo build
</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/core.html#admonition-tip-1"></a>
</div>
<div>
<p>If you have problems building, make sure your <code>Capabilities</code> struct implements the <code>Export</code> trait.
There is a derive macro that can do this for you, e.g.:</p>
<pre><code class="language-rust ignore">#[cfg_attr(feature = "typegen", derive(crux_core::macros::Export))]
#[derive(crux_core::macros::Effect)]
pub struct Capabilities {
    render: Render&lt;Event&gt;,
    http: Http&lt;Event&gt;,
}</code></pre>
<p>The <code>Export</code> and <code>Effect</code> derive macros can be configured with the <code>effect</code> attribute if you need to specify a different name for the Effect type e.g.:</p>
<pre><code class="language-rust ignore">#[cfg_attr(feature = "typegen", derive(Export))]
#[derive(Effect)]
#[effect(name = "MyEffect")]
pub struct Capabilities {
    render: Render&lt;Event&gt;,
    pub_sub: PubSub&lt;Event&gt;,
}</code></pre>
<p>Additionally, if you are using a Capability that does not need to be exported to the foreign language, you can use the <code>#[effect(skip)]</code> attribute to skip exporting it, e.g.:</p>
<pre><code class="language-rust ignore">#[cfg_attr(feature = "typegen", derive(Export))]
#[derive(Effect)]
pub struct Capabilities {
    render: Render&lt;Event&gt;,
    #[effect(skip)]
    compose: Compose&lt;Event&gt;,
}</code></pre>
</div>
</div>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/core.html#admonition-success"></a>
</div>
<div>
<p>You should now be ready to set up <a href="getting_started/iOS/index.html">iOS</a>, <a href="getting_started/Android/index.html">Android</a>, or <a href="getting_started/web/index.html">web</a> specific builds.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios"><a class="header" href="#ios">iOS</a></h1>
<p>When we use Crux to build iOS apps, the Core API bindings are generated in Swift
(with C headers) using Mozilla's <a href="https://mozilla.github.io/uniffi-rs/">Uniffi</a>.</p>
<p>The shared core (that contains our app's behavior) is compiled to a static
library and linked into the iOS binary. To do this we use
<a href="https://crates.io/crates/cargo-xcode"><code>cargo-xcode</code></a> to generate an Xcode
project for the shared core, which we can include as a sub-project in our iOS
app.</p>
<p>The shared types are generated by Crux as a Swift package, which we can add to
our iOS project as a dependency. The Swift code to serialize and deserialize
these types across the boundary is also generated by Crux as Swift packages.</p>
<p><img src="getting_started/iOS/./flow.svg" alt="build flow" /></p>
<p>This section has two guides for building iOS apps with Crux:</p>
<ol>
<li><a href="getting_started/iOS/./with_xcodegen.html">Swift and SwiftUI (XcodeGen)</a></li>
<li><a href="getting_started/iOS/./manual.html">Swift and SwiftUI (manual)</a></li>
</ol>
<p>We recommend the first option, as it's definitely the simplest way to get
started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios--swift-and-swiftui--using-xcodegen"><a class="header" href="#ios--swift-and-swiftui--using-xcodegen">iOS — Swift and SwiftUI — using XcodeGen</a></h1>
<p>These are the steps to set up Xcode to build and run a simple iOS app that calls
into a shared core.</p>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/with_xcodegen.html#admonition-tip"></a>
</div>
<div>
<p>We think that using <a href="https://github.com/yonaskolb/XcodeGen">XcodeGen</a> may be the simplest way to create an Xcode project to build and run a simple iOS app that calls into a shared core. If you'd rather set up Xcode manually, you can jump to <a href="getting_started/iOS/./manual.html">iOS — Swift and SwiftUI — manual setup</a>, otherwise read on.</p>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/with_xcodegen.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code> libraries to your repo — as described in <a href="getting_started/iOS/../core.html">Shared core and types</a>.</p>
</div>
</div>
<h2 id="compile-our-rust-shared-library"><a class="header" href="#compile-our-rust-shared-library">Compile our Rust shared library</a></h2>
<p>When we build our iOS app, we also want to build the Rust core as a static
library so that it can be linked into the binary that we're going to ship.</p>
<p>We will use <a href="https://crates.io/crates/cargo-xcode"><code>cargo-xcode</code></a> to generate an
Xcode project for our shared library, which we can add as a sub-project in
Xcode.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/with_xcodegen.html#admonition-note-1"></a>
</div>
<div>
<p>Recent changes to <code>cargo-xcode</code> mean that we need to use version &lt;=1.7.0 for
now.</p>
<p>If you don't have this already, you can install it in one of two ways:</p>
<ol>
<li>
<p>Globally, with <code>cargo install --force cargo-xcode --version 1.7.0</code></p>
</li>
<li>
<p>Locally, using
<a href="https://github.com/dustinblackman/cargo-run-bin"><code>cargo-run-bin</code></a>, after
ensuring that your <code>Cargo.toml</code> has the following lines (see
<a href="getting_started/iOS/../core.html#the-workspace-and-library-manifests">The workspace and library manifests</a>):</p>
<pre><code class="language-toml">[workspace.metadata.bin]
cargo-xcode = { version = "=1.7.0" }
</code></pre>
<p>Ensure you have <code>cargo-run-bin</code> (and optionally <code>cargo-binstall</code>) installed:</p>
<pre><code class="language-bash">cargo install cargo-run-bin cargo-binstall
</code></pre>
<p>Then, in the root of your app:</p>
<pre><code class="language-bash">cargo bin --install # will be faster if `cargo-binstall` is installed
cargo bin --sync-aliases # to use `cargo xcode` instead of `cargo bin xcode`
</code></pre>
</li>
</ol>
</div>
</div>
<p>Let's generate the sub-project:</p>
<pre><code class="language-bash">cargo xcode
</code></pre>
<p>This generates an Xcode project for each crate in the workspace, but we're only
interested in the one it creates in the <code>shared</code> directory. Don't open this
generated project yet, it'll be included when we generate the Xcode project for
our iOS app.</p>
<h2 id="generate-the-xcode-project-for-our-ios-app"><a class="header" href="#generate-the-xcode-project-for-our-ios-app">Generate the Xcode project for our iOS app</a></h2>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/with_xcodegen.html#admonition-note-2"></a>
</div>
<div>
<p>We will use <a href="https://github.com/yonaskolb/XcodeGen"><code>XcodeGen</code></a> to generate an Xcode project for our iOS app.</p>
<p>If you don't have this already, you can install it with <code>brew install xcodegen</code>.</p>
</div>
</div>
<p>Before we generate the Xcode project, we need to create some directories and a
<code>project.yml</code> file:</p>
<pre><code class="language-bash">mkdir -p iOS/SimpleCounter
cd iOS
touch project.yml
</code></pre>
<p>The <code>project.yml</code> file describes the Xcode project we want to generate. Here's
one for the SimpleCounter example — you may want to adapt this for your own
project:</p>
<pre><code class="language-yaml">name: SimpleCounter
projectReferences:
  Shared:
    path: ../shared/shared.xcodeproj
packages:
  SharedTypes:
    path: ../shared_types/generated/swift/SharedTypes
options:
  bundleIdPrefix: com.example.simple_counter
attributes:
  BuildIndependentTargetsInParallel: true
targets:
  SimpleCounter:
    type: application
    platform: iOS
    deploymentTarget: "15.0"
    sources:
      - SimpleCounter
      - path: ../shared/src/shared.udl
        buildPhase: sources
    dependencies:
      - target: Shared/uniffi-bindgen-bin
      - target: Shared/shared-staticlib
      - package: SharedTypes
    info:
      path: SimpleCounter/Info.plist
      properties:
        UISupportedInterfaceOrientations:
          - UIInterfaceOrientationPortrait
          - UIInterfaceOrientationLandscapeLeft
          - UIInterfaceOrientationLandscapeRight
        UILaunchScreen: {}
    settings:
      OTHER_LDFLAGS: [-w]
      SWIFT_OBJC_BRIDGING_HEADER: generated/sharedFFI.h
      ENABLE_USER_SCRIPT_SANDBOXING: NO
    buildRules:
      - name: Generate FFI
        filePattern: "*.udl"
        script: |
          #!/bin/bash
          set -e

          # Skip during indexing phase in XCode 13+
          if [ "$ACTION" == "indexbuild" ]; then
            echo "Not building *.udl files during indexing."
            exit 0
          fi

          # Skip for preview builds
          if [ "$ENABLE_PREVIEWS" = "YES" ]; then
            echo "Not building *.udl files during preview builds."
            exit 0
          fi

          cd "${INPUT_FILE_DIR}/.."
          "${BUILD_DIR}/debug/uniffi-bindgen" generate "src/${INPUT_FILE_NAME}" --language swift --out-dir "${PROJECT_DIR}/generated"
        outputFiles:
          - $(PROJECT_DIR)/generated/$(INPUT_FILE_BASE).swift
          - $(PROJECT_DIR)/generated/$(INPUT_FILE_BASE)FFI.h
        runOncePerArchitecture: false
</code></pre>
<p>Then we can generate the Xcode project:</p>
<pre><code class="language-bash">xcodegen
</code></pre>
<p>This should create an <code>iOS/SimpleCounter/SimpleCounter.xcodeproj</code> project file,
which we can open in Xcode. It should build OK, but we will need to add some
code!</p>
<h2 id="create-some-ui-and-run-in-the-simulator-or-on-an-iphone"><a class="header" href="#create-some-ui-and-run-in-the-simulator-or-on-an-iphone">Create some UI and run in the Simulator, or on an iPhone</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/with_xcodegen.html#admonition-example"></a>
</div>
<div>
<p>There is slightly more advanced
<a href="https://github.com/redbadger/crux/tree/master/examples/counter">example</a> of an
iOS app in the Crux repository.</p>
<p>However, we will use the
<a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter">simple counter example</a>,
which has <code>shared</code> and <code>shared_types</code> libraries that will work with the
following example code.</p>
</div>
</div>
<h3 id="simple-counter-example"><a class="header" href="#simple-counter-example">Simple counter example</a></h3>
<p>A simple app that increments, decrements and resets a counter.</p>
<h4 id="wrap-the-core-to-support-capabilities"><a class="header" href="#wrap-the-core-to-support-capabilities">Wrap the core to support capabilities</a></h4>
<p>First, let's add some boilerplate code to wrap our core and handle the
capabilities that we are using. For this example, we only need to support the
<code>Render</code> capability, which triggers a render of the UI.</p>
<div id="admonition-note-3" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-3-title">
<div class="admonition-title">
<div id="admonition-note-3-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/with_xcodegen.html#admonition-note-3"></a>
</div>
<div>
<p>This code that wraps the core only needs to be written once — it only grows when
we need to support additional capabilities.</p>
</div>
</div>
<p>Edit <code>iOS/SimpleCounter/core.swift</code> to look like the following. This code sends
our (UI-generated) events to the core, and handles any effects that the core
asks for. In this simple example, we aren't calling any HTTP APIs or handling
any side effects other than rendering the UI, so we just handle this render
effect by updating the published view model from the core.</p>
<pre><code class="language-swift">import Foundation
import SharedTypes

@MainActor
class Core: ObservableObject {
    @Published var view: ViewModel
    
    init() {
        self.view = try! .bincodeDeserialize(input: [UInt8](SimpleCounter.view()))
    }
    
    func update(_ event: Event) {
        let effects = [UInt8](processEvent(Data(try! event.bincodeSerialize())))
        
        let requests: [Request] = try! .bincodeDeserialize(input: effects)
        for request in requests {
            processEffect(request)
        }
    }
    
    func processEffect(_ request: Request) {
        switch request.effect {
        case .render:
            view = try! .bincodeDeserialize(input: [UInt8](SimpleCounter.view()))
        }
    }
}
</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/with_xcodegen.html#admonition-tip-1"></a>
</div>
<div>
<p>That <code>switch</code> statement, above, is where you would handle any other effects that
your core might ask for. For example, if your core needs to make an HTTP
request, you would handle that here. To see an example of this, take a look at
the
<a href="https://github.com/redbadger/crux/tree/master/examples/counter/iOS/CounterApp/core.swift">counter example</a>
in the Crux repository.</p>
</div>
</div>
<p>Edit <code>iOS/SimpleCounter/ContentView.swift</code> to look like the following:</p>
<pre><code class="language-swift">import SharedTypes
import SwiftUI

struct ContentView: View {
    @ObservedObject var core: Core

    var body: some View {
        VStack {
            Image(systemName: "globe")
                .imageScale(.large)
                .foregroundColor(.accentColor)
            Text(core.view.count)
            HStack {
                ActionButton(label: "Reset", color: .red) {
                    core.update(.reset)
                }
                ActionButton(label: "Inc", color: .green) {
                    core.update(.increment)
                }
                ActionButton(label: "Dec", color: .yellow) {
                    core.update(.decrement)
                }
            }
        }
    }
}

struct ActionButton: View {
    var label: String
    var color: Color
    var action: () -&gt; Void

    init(label: String, color: Color, action: @escaping () -&gt; Void) {
        self.label = label
        self.color = color
        self.action = action
    }

    var body: some View {
        Button(action: action) {
            Text(label)
                .fontWeight(.bold)
                .font(.body)
                .padding(EdgeInsets(top: 10, leading: 15, bottom: 10, trailing: 15))
                .background(color)
                .cornerRadius(10)
                .foregroundColor(.white)
                .padding()
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(core: Core())
    }
}
</code></pre>
<p>And create <code>iOS/SimpleCounter/SimpleCounterApp.swift</code> to look like this:</p>
<pre><code class="language-swift">import SwiftUI

@main
struct SimpleCounterApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView(core: Core())
        }
    }
}
</code></pre>
<p>Run <code>xcodegen</code> again to update the Xcode project with these newly created source
files (or add them manually in Xcode to the <code>SimpleCounter</code> group), and then
open <code>iOS/SimpleCounter/SimpleCounter.xcodeproj</code> in Xcode. You might need to
select the <code>SimpleCounter</code> scheme, and an appropriate simulator, in the
drop-down at the top, before you build.</p>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/with_xcodegen.html#admonition-success"></a>
</div>
<div>
<p>You should then be able to run the app in the simulator or on an iPhone, and it should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/iOS/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios--swift-and-swiftui--manual-setup"><a class="header" href="#ios--swift-and-swiftui--manual-setup">iOS — Swift and SwiftUI — manual setup</a></h1>
<p>These are the steps to set up Xcode to build and run a simple iOS app that calls
into a shared core.</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/manual.html#admonition-warning"></a>
</div>
<div>
<p>We recommend setting up Xcode with XcodeGen as described in the
<a href="getting_started/iOS/./with_xcodegen.html">previous section</a>. It is the simplest way to create an Xcode
project to build and run a simple iOS app that calls into a shared core. However,
if you want to set up Xcode manually then read on.</p>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/manual.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code>
libraries to your repo — as described in <a href="getting_started/iOS/../core.html">Shared core and types</a>
— and that you have built them using <code>cargo build</code>.</p>
</div>
</div>
<h2 id="create-an-ios-app"><a class="header" href="#create-an-ios-app">Create an iOS App</a></h2>
<p>The first thing we need to do is create a new iOS app in Xcode.</p>
<p>Let's call the app "SimpleCounter" and select "SwiftUI" for the interface and
"Swift" for the language. If you choose to create the app in the root folder of
your monorepo, then you might want to rename the folder it creates to "iOS".
Your repo's directory structure might now look something like this (some files
elided):</p>
<pre><code class="language-txt">.
├── Cargo.lock
├── Cargo.toml
├── iOS
│  ├── SimpleCounter
│  │  ├── ContentView.swift
│  │  └── SimpleCounterApp.swift
│  └── SimpleCounter.xcodeproj
│     └── project.pbxproj
├── shared
│  ├── build.rs
│  ├── Cargo.toml
│  ├── src
│  │  ├── counter.rs
│  │  ├── lib.rs
│  │  └── shared.udl
│  └── uniffi.toml
├── shared_types
│  ├── build.rs
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
└── target
</code></pre>
<h2 id="generate-ffi-bindings"><a class="header" href="#generate-ffi-bindings">Generate FFI bindings</a></h2>
<p>We want UniFFI to create the Swift bindings and the C headers for our shared
library, and store them in a directory called <code>generated</code>.</p>
<p>To achieve this, we'll associate a script with files that match the pattern
<code>*.udl</code> (this will catch the interface definition file we created earlier), and
then add our <code>shared.udl</code> file to the project.</p>
<p>Note that our shared library generates the <code>uniffi-bindgen</code> binary (as explained
on the page <a href="getting_started/iOS/../core.html">"Shared core and types"</a>) that the script relies on, so
make sure you have built it already, using <code>cargo build</code>.</p>
<p>In "<strong>Build Rules</strong>", add a rule to process files that match the pattern <code>*.udl</code>
with the following script (and also uncheck "<strong>Run once per architecture</strong>").</p>
<pre><code class="language-bash">#!/bin/bash
set -e

# Skip during indexing phase in XCode 13+
if [ "$ACTION" == "indexbuild" ]; then
   echo "Not building *.udl files during indexing."
   exit 0
fi

# Skip for preview builds
if [ "$ENABLE_PREVIEWS" = "YES" ]; then
   echo "Not building *.udl files during preview builds."
   exit 0
fi

cd "${INPUT_FILE_DIR}/.."
"${BUILD_DIR}/debug/uniffi-bindgen" generate "src/${INPUT_FILE_NAME}" --language swift --out-dir "${PROJECT_DIR}/generated"

</code></pre>
<p>We'll need to add the following as output files:</p>
<pre><code class="language-txt">$(PROJECT_DIR)/generated/$(INPUT_FILE_BASE).swift
</code></pre>
<pre><code class="language-txt">$(PROJECT_DIR)/generated/$(INPUT_FILE_BASE)FFI.h
</code></pre>
<p>Now go to the project settings, "<strong>Build Phases, Compile Sources</strong>", and add <code>/shared/src/shared.udl</code>
using the "add other" button, selecting "Create folder references".</p>
<p>You may also need to go to "<strong>Build Settings, User Script Sandboxing</strong>" and set this
to <code>No</code> to give the script permission to create files.</p>
<p>Build the project (cmd-B), which will fail, but the above script should run
successfully and the "generated" folder should contain the generated Swift types
and C header files:</p>
<pre><code class="language-bash">$ ls iOS/generated
shared.swift  sharedFFI.h  sharedFFI.modulemap
</code></pre>
<h3 id="add-the-bridging-header"><a class="header" href="#add-the-bridging-header">Add the bridging header</a></h3>
<p>In "<strong>Build Settings</strong>", search for "bridging header", and add
<code>generated/sharedFFI.h</code>, for any architecture/SDK, i.e. in both Debug and
Release. If there isn't already a setting for "bridging header" you can add one
(and then delete it) as per
<a href="https://stackoverflow.com/questions/41787935/how-to-use-objective-c-bridging-header-in-a-swift-project/41788055#41788055">this StackOverflow question</a></p>
<h2 id="compile-our-rust-shared-library-1"><a class="header" href="#compile-our-rust-shared-library-1">Compile our Rust shared library</a></h2>
<p>When we build our iOS app, we also want to build the Rust core as a static
library so that it can be linked into the binary that we're going to ship.</p>
<p>We will use <a href="https://crates.io/crates/cargo-xcode"><code>cargo-xcode</code></a> to generate an
Xcode project for our shared library, which we can add as a sub-project in
Xcode.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/manual.html#admonition-note-1"></a>
</div>
<div>
<p>Recent changes to <code>cargo-xcode</code> mean that we need to use version &lt;=1.7.0 for
now.</p>
<p>If you don't have this already, you can install it in one of two ways:</p>
<ol>
<li>
<p>Globally, with <code>cargo install --force cargo-xcode --version 1.7.0</code></p>
</li>
<li>
<p>Locally, using
<a href="https://github.com/dustinblackman/cargo-run-bin"><code>cargo-run-bin</code></a>, after
ensuring that your <code>Cargo.toml</code> has the following lines (see
<a href="getting_started/iOS/../core.html#the-workspace-and-library-manifests">The workspace and library manifests</a>):</p>
<pre><code class="language-toml">[workspace.metadata.bin]
cargo-xcode = { version = "=1.7.0" }
</code></pre>
<p>Ensure you have <code>cargo-run-bin</code> (and optionally <code>cargo-binstall</code>) installed:</p>
<pre><code class="language-bash">cargo install cargo-run-bin cargo-binstall
</code></pre>
<p>Then, in the root of your app:</p>
<pre><code class="language-bash">cargo bin --install # will be faster if `cargo-binstall` is installed
cargo bin --sync-aliases # to use `cargo xcode` instead of `cargo bin xcode`
</code></pre>
</li>
</ol>
</div>
</div>
<p>Let's generate the sub-project:</p>
<pre><code class="language-bash">cargo xcode
</code></pre>
<p>This generates an Xcode project for each crate in the workspace, but we're only
interested in the one it creates in the <code>shared</code> directory. Don't open this
generated project yet.</p>
<p>Using Finder, drag the <code>shared/shared.xcodeproj</code> folder under the Xcode project
root.</p>
<p>Then, in the "<strong>Build Phases, Link Binary with Libraries</strong>" section, add the
<code>libshared_static.a</code> library (you should be able to navigate to it as
<code>Workspace -&gt; shared -&gt; libshared_static.a</code>)</p>
<h2 id="add-the-shared-types"><a class="header" href="#add-the-shared-types">Add the Shared Types</a></h2>
<p>Using Finder, drag the <code>shared_types/generated/swift/SharedTypes</code> folder under
the Xcode project root.</p>
<p>Then, in the "<strong>Build Phases, Link Binary with Libraries</strong>" section, add the
<code>SharedTypes</code> library (you should be able to navigate to it as
<code>Workspace -&gt; SharedTypes -&gt; SharedTypes</code>)</p>
<h2 id="create-some-ui-and-run-in-the-simulator-or-on-an-iphone-1"><a class="header" href="#create-some-ui-and-run-in-the-simulator-or-on-an-iphone-1">Create some UI and run in the Simulator, or on an iPhone</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/manual.html#admonition-example"></a>
</div>
<div>
<p>There is slightly more advanced
<a href="https://github.com/redbadger/crux/tree/master/examples/counter">example</a> of an
iOS app in the Crux repository.</p>
<p>However, we will use the
<a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter">simple counter example</a>,
which has <code>shared</code> and <code>shared_types</code> libraries that will work with the
following example code.</p>
</div>
</div>
<h3 id="simple-counter-example-1"><a class="header" href="#simple-counter-example-1">Simple counter example</a></h3>
<p>A simple app that increments, decrements and resets a counter.</p>
<h4 id="wrap-the-core-to-support-capabilities-1"><a class="header" href="#wrap-the-core-to-support-capabilities-1">Wrap the core to support capabilities</a></h4>
<p>First, let's add some boilerplate code to wrap our core and handle the
capabilities that we are using. For this example, we only need to support the
<code>Render</code> capability, which triggers a render of the UI.</p>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/manual.html#admonition-note-2"></a>
</div>
<div>
<p>This code that wraps the core only needs to be written once — it only grows when
we need to support additional capabilities.</p>
</div>
</div>
<p>Edit <code>iOS/SimpleCounter/core.swift</code> to look like the following. This code sends
our (UI-generated) events to the core, and handles any effects that the core
asks for. In this simple example, we aren't calling any HTTP APIs or handling
any side effects other than rendering the UI, so we just handle this render
effect by updating the published view model from the core.</p>
<pre><code class="language-swift">import Foundation
import SharedTypes

@MainActor
class Core: ObservableObject {
    @Published var view: ViewModel
    
    init() {
        self.view = try! .bincodeDeserialize(input: [UInt8](SimpleCounter.view()))
    }
    
    func update(_ event: Event) {
        let effects = [UInt8](processEvent(Data(try! event.bincodeSerialize())))
        
        let requests: [Request] = try! .bincodeDeserialize(input: effects)
        for request in requests {
            processEffect(request)
        }
    }
    
    func processEffect(_ request: Request) {
        switch request.effect {
        case .render:
            view = try! .bincodeDeserialize(input: [UInt8](SimpleCounter.view()))
        }
    }
}
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/manual.html#admonition-tip"></a>
</div>
<div>
<p>That <code>switch</code> statement, above, is where you would handle any other effects that
your core might ask for. For example, if your core needs to make an HTTP
request, you would handle that here. To see an example of this, take a look at
the
<a href="https://github.com/redbadger/crux/tree/master/examples/counter/iOS/CounterApp/core.swift">counter example</a>
in the Crux repository.</p>
</div>
</div>
<p>Edit <code>iOS/SimpleCounter/ContentView.swift</code> to look like the following:</p>
<pre><code class="language-swift">import SharedTypes
import SwiftUI

struct ContentView: View {
    @ObservedObject var core: Core

    var body: some View {
        VStack {
            Image(systemName: "globe")
                .imageScale(.large)
                .foregroundColor(.accentColor)
            Text(core.view.count)
            HStack {
                ActionButton(label: "Reset", color: .red) {
                    core.update(.reset)
                }
                ActionButton(label: "Inc", color: .green) {
                    core.update(.increment)
                }
                ActionButton(label: "Dec", color: .yellow) {
                    core.update(.decrement)
                }
            }
        }
    }
}

struct ActionButton: View {
    var label: String
    var color: Color
    var action: () -&gt; Void

    init(label: String, color: Color, action: @escaping () -&gt; Void) {
        self.label = label
        self.color = color
        self.action = action
    }

    var body: some View {
        Button(action: action) {
            Text(label)
                .fontWeight(.bold)
                .font(.body)
                .padding(EdgeInsets(top: 10, leading: 15, bottom: 10, trailing: 15))
                .background(color)
                .cornerRadius(10)
                .foregroundColor(.white)
                .padding()
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(core: Core())
    }
}
</code></pre>
<p>And create <code>iOS/SimpleCounter/SimpleCounterApp.swift</code> to look like this:</p>
<pre><code class="language-swift">import SwiftUI

@main
struct SimpleCounterApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView(core: Core())
        }
    }
}
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/iOS/manual.html#admonition-success"></a>
</div>
<div>
<p>You should then be able to run the app in the simulator or on an iPhone, and it should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/iOS/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android"><a class="header" href="#android">Android</a></h1>
<p>When we use Crux to build Android apps, the Core API bindings are generated in
Java using Mozilla's <a href="https://mozilla.github.io/uniffi-rs/">Uniffi</a>.</p>
<p>The shared core (that contains our app's behavior) is compiled to a dynamic
library, using Mozilla's
<a href="https://github.com/mozilla/rust-android-gradle">Rust gradle plugin</a> for Android
and the <a href="https://developer.android.com/ndk">Android NDK</a>. The library is loaded
at runtime using
<a href="https://github.com/java-native-access/jna">Java Native Access</a>.</p>
<p>The shared types are generated by Crux as Java packages, which we can add to our
Android project using <code>sourceSets</code>. The Java code to serialize and deserialize
these types across the boundary is also generated by Crux as Java packages.</p>
<p><img src="getting_started/Android/./flow.svg" alt="build flow" /></p>
<p>This section has a guide for building Android apps with Crux:</p>
<ol>
<li><a href="getting_started/Android/./android.html">Kotlin and Jetpack Compose</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android--kotlin-and-jetpack-compose"><a class="header" href="#android--kotlin-and-jetpack-compose">Android — Kotlin and Jetpack Compose</a></h1>
<p>These are the steps to set up Android Studio to build and run a simple Android
app that calls into a shared core.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code> libraries to your repo, as described in <a href="getting_started/Android/../core.html">Shared core and types</a>.</p>
</div>
</div>
<div id="admonition-sharp-edge" class="admonition admonish-warning" role="note" aria-labelledby="admonition-sharp-edge-title">
<div class="admonition-title">
<div id="admonition-sharp-edge-title">
<p>Sharp edge</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-sharp-edge"></a>
</div>
<div>
<p>We want to make setting up Android Studio to work with Crux really easy. As time progresses we will try to simplify and automate as much as possible, but at the moment there is some manual configuration to do. This only needs doing once, so we hope it's not too much trouble. If you know of any better ways than those we describe below, please either raise an issue (or a PR) at <a href="https://github.com/redbadger/crux">https://github.com/redbadger/crux</a>.</p>
</div>
</div>
<div id="admonition-rust-gradle-plugin" class="admonition admonish-bug" role="note" aria-labelledby="admonition-rust-gradle-plugin-title">
<div class="admonition-title">
<div id="admonition-rust-gradle-plugin-title">
<p>Rust gradle plugin</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-rust-gradle-plugin"></a>
</div>
<div>
<p>This walkthrough uses Mozilla's excellent <a href="https://github.com/mozilla/rust-android-gradle">Rust gradle plugin</a>
for Android, which uses Python. However, <code>pipes</code> has recently been removed from Python (since Python 3.13)
so you may encounter an error linking your shared library.</p>
<p>If you hit this problem, you can either:</p>
<ol>
<li>use an older Python (&lt;3.13)</li>
<li>wait for a fix (see <a href="https://github.com/mozilla/rust-android-gradle/issues/153">this issue</a>)</li>
<li>or use a different plugin — there is a <a href="https://github.com/redbadger/crux/pull/274">PR in the Crux repo</a> that
explores the use of <a href="https://github.com/bbqsrc/cargo-ndk"><code>cargo-ndk</code></a>
and the <a href="https://github.com/willir/cargo-ndk-android-gradle"><code>cargo-ndk-android</code></a>
plugin that may be useful.</li>
</ol>
</div>
</div>
<h2 id="create-an-android-app"><a class="header" href="#create-an-android-app">Create an Android App</a></h2>
<p>The first thing we need to do is create a new Android app in Android Studio.</p>
<p>Open Android Studio and create a new project, for "Phone and Tablet", of type
"Empty Activity". In this walk-through, we'll call it "SimpleCounter"</p>
<ul>
<li>"Name": <code>SimpleCounter</code></li>
<li>"Package name": <code>com.example.simple_counter</code></li>
<li>"Save Location": a directory called <code>Android</code> at the root of our monorepo</li>
<li>"Minimum SDK" <code>API 34</code></li>
<li>"Build configuration language": <code>Groovy DSL (build.gradle)</code></li>
</ul>
<p>Your repo's directory structure might now look something like this (some files
elided):</p>
<pre><code class="language-txt">.
├── Android
│  ├── app
│  │  ├── build.gradle
│  │  ├── libs
│  │  └── src
│  │     └── main
│  │        ├── AndroidManifest.xml
│  │        └── java
│  │           └── com
│  │              └── example
│  │                 └── simple_counter
│  │                    └── MainActivity.kt
│  ├── build.gradle
│  ├── gradle.properties
│  ├── local.properties
│  └── settings.gradle
├── Cargo.lock
├── Cargo.toml
├── shared
│  ├── build.rs
│  ├── Cargo.toml
│  ├── src
│  │  ├── app.rs
│  │  ├── lib.rs
│  │  └── shared.udl
│  └── uniffi.toml
├── shared_types
│  ├── build.rs
│  ├── Cargo.toml
│  └── src
│     └── lib.rs
└── target
</code></pre>
<h2 id="add-a-kotlin-android-library"><a class="header" href="#add-a-kotlin-android-library">Add a Kotlin Android Library</a></h2>
<p>This shared Android library (<code>aar</code>) is going to wrap our shared Rust library.</p>
<p>Under <code>File -&gt; New -&gt; New Module</code>, choose "Android Library" and give it the "Module name"
<code>shared</code>. Set the "Package name" to match the one from your
<code>/shared/uniffi.toml</code>, which in this example is <code>com.example.simple_counter.shared</code>.</p>
<p>Again, set the "Build configuration language" to <code>Groovy DSL (build.gradle)</code>.</p>
<p>For more information on how to add an Android library see
<a href="https://developer.android.com/studio/projects/android-library">https://developer.android.com/studio/projects/android-library</a>.</p>
<p>We can now add this library as a <em>dependency</em> of our app.</p>
<p>Edit the <strong>app</strong>'s <code>build.gradle</code> (<code>/Android/app/build.gradle</code>) to look like
this:</p>
<pre><code class="language-gradle">plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
}

android {
    namespace 'com.example.simple_counter'
    compileSdk 34

    defaultConfig {
        applicationId "com.example.simple_counter"
        minSdk 34
        targetSdk 34
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_20
        targetCompatibility JavaVersion.VERSION_20
    }
    kotlinOptions {
        jvmTarget = '20'
    }
    buildFeatures {
        compose true
    }
}

dependencies {
    // our shared library
    implementation project(path: ':shared')

    // added dependencies
    implementation libs.lifecycle.viewmodel.compose

    // original dependencies
    implementation libs.androidx.core.ktx
    implementation libs.androidx.lifecycle.runtime.ktx
    implementation libs.androidx.activity.compose
    implementation platform(libs.androidx.compose.bom)
    implementation libs.androidx.ui
    implementation libs.androidx.ui.graphics
    implementation libs.androidx.ui.tooling.preview
    implementation libs.androidx.material3
    testImplementation libs.junit
    androidTestImplementation libs.androidx.junit
    androidTestImplementation libs.androidx.espresso.core
    androidTestImplementation platform(libs.androidx.compose.bom)
    androidTestImplementation libs.androidx.ui.test.junit4
    debugImplementation libs.androidx.ui.tooling
    debugImplementation libs.androidx.ui.test.manifest
}
</code></pre>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-note-1"></a>
</div>
<div>
<p>In our gradle files, we are referencing a "Version Catalog" to manage our dependency versions, so you
will need to ensure this is kept up to date.</p>
<p>Our catalog (<code>Android/gradle/libs.versions.toml</code>) will end up looking like this:</p>
<pre><code class="language-toml">[versions]
agp = "8.7.0"
kotlin = "2.0.0"
coreKtx = "1.13.1"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
lifecycleRuntimeKtx = "2.8.6"
activityCompose = "1.9.2"
composeBom = "2024.09.03"

# added
jna = "5.15.0"
lifecycle = "2.8.6"
appcompat = "1.7.0"
material = "1.12.0"
rustAndroid = "0.9.4"

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }

# added
jna = { module = "net.java.dev.jna:jna", version.ref = "jna" }
lifecycle-viewmodel-compose = { module = "androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "lifecycle" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
material = { group = "com.google.android.material", name = "material", version.ref = "material" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
kotlin-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }

# added
rust-android = { id = "org.mozilla.rust-android-gradle.rust-android", version.ref = "rustAndroid" }
android-library = { id = "com.android.library", version.ref = "agp" }
</code></pre>
</div>
</div>
<h2 id="the-rust-shared-library"><a class="header" href="#the-rust-shared-library">The Rust shared library</a></h2>
<p>We'll use the following tools to incorporate our Rust shared library into the
Android library added above. This includes compiling and linking the Rust
dynamic library and generating the runtime bindings and the shared types.</p>
<ul>
<li>The <a href="https://developer.android.com/ndk">Android NDK</a></li>
<li>Mozilla's <a href="https://github.com/mozilla/rust-android-gradle">Rust gradle plugin</a>
for Android
<ul>
<li>This plugin depends on Python 3, make sure you have a version installed</li>
</ul>
</li>
<li><a href="https://github.com/java-native-access/jna">Java Native Access</a></li>
<li><a href="https://mozilla.github.io/uniffi-rs/">Uniffi</a> to generate Java bindings</li>
</ul>
<p>The NDK can be installed from "<strong>Tools, SDK Manager, SDK Tools</strong>" in Android Studio.</p>
<p>Let's get started.</p>
<p>Add the four rust android toolchains to your system:</p>
<pre><code class="language-sh">$ rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android
</code></pre>
<p>Edit the <strong>project</strong>'s <code>build.gradle</code> (<code>/Android/build.gradle</code>) to look like
this:</p>
<pre><code class="language-gradle">// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.kotlin.compose) apply false
    alias(libs.plugins.android.library) apply false
    alias(libs.plugins.rust.android) apply false
}
</code></pre>
<p>Edit the <strong>library</strong>'s <code>build.gradle</code> (<code>/Android/shared/build.gradle</code>) to look
like this:</p>
<pre><code class="language-gradle">plugins {
    alias(libs.plugins.android.library)
    alias(libs.plugins.kotlin.android)
}

android {
    namespace 'com.example.simple_counter.shared'
    compileSdk 34

    ndkVersion "27.1.12297006"

    defaultConfig {
        minSdk 34

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles "consumer-rules.pro"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_20
        targetCompatibility JavaVersion.VERSION_20
    }
    kotlinOptions {
        jvmTarget = '20'
    }
    sourceSets {
        main.java.srcDirs += "${projectDir}/../../shared_types/generated/java"
    }
}

dependencies {
    // added
    implementation(libs.jna) {
        artifact {
            type = "aar"
        }
    }

    // original
    implementation libs.androidx.core.ktx
    implementation libs.androidx.appcompat
    implementation libs.material
    testImplementation libs.junit
    androidTestImplementation libs.androidx.junit
    androidTestImplementation libs.androidx.espresso.core
}


apply plugin: 'org.mozilla.rust-android-gradle.rust-android'

cargo {
    module = "../.."
    libname = "shared"
    // these are the four recommended targets for Android that will ensure your library works on all mainline android devices
    // make sure you have included the rust toolchain for each of these targets: \
    // `rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android`
    targets = ["arm", "arm64", "x86", "x86_64"]
    extraCargoBuildArguments = ['--package', 'shared']
    cargoCommand = System.getProperty("user.home") + "/.cargo/bin/cargo"
    rustcCommand = System.getProperty("user.home") + "/.cargo/bin/rustc"
    pythonCommand = "python3"
}

afterEvaluate {
    // The `cargoBuild` task isn't available until after evaluation.
    android.libraryVariants.configureEach { variant -&gt;
        def productFlavor = ""
        variant.productFlavors.each {
            productFlavor += "${it.name.capitalize()}"
        }
        def buildType = "${variant.buildType.name.capitalize()}"

        tasks.named("compileDebugKotlin") {
            it.dependsOn(tasks.named("typesGen"), tasks.named("bindGen"))
        }

        tasks.named("generate${productFlavor}${buildType}Assets") {
            it.dependsOn(tasks.named("cargoBuild"))
        }
    }
}

tasks.register('bindGen', Exec) {
    def outDir = "${projectDir}/../../shared_types/generated/java"
    workingDir "../../"
    if (System.getProperty('os.name').toLowerCase().contains('windows')) {
        commandLine("cmd", "/c",
                "cargo build -p shared &amp;&amp; " + "target\\debug\\uniffi-bindgen generate shared\\src\\shared.udl " + "--language kotlin " + "--out-dir " + outDir.replace('/', '\\'))
    } else {
        commandLine("sh", "-c",
                """\
                cargo build -p shared &amp;&amp; \
                target/debug/uniffi-bindgen generate shared/src/shared.udl \
                --language kotlin \
                --out-dir $outDir
                """)
    }
}

tasks.register('typesGen', Exec) {
    workingDir "../../"
    if (System.getProperty('os.name').toLowerCase().contains('windows')) {
        commandLine("cmd", "/c", "cargo build -p shared_types")
    } else {
        commandLine("sh", "-c", "cargo build -p shared_types")
    }
}

</code></pre>
<div id="admonition-sharp-edge-1" class="admonition admonish-warning" role="note" aria-labelledby="admonition-sharp-edge-1-title">
<div class="admonition-title">
<div id="admonition-sharp-edge-1-title">
<p>Sharp edge</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-sharp-edge-1"></a>
</div>
<div>
<p>You will need to set the <code>ndkVersion</code> to one you have installed, go to "<strong>Tools, SDK Manager, SDK Tools</strong>" and check "<strong>Show Package Details</strong>" to get your installed version, or to install the version matching <code>build.gradle</code> above.</p>
</div>
</div>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-tip"></a>
</div>
<div>
<p>When you have edited the gradle files, don't forget to click "sync now".</p>
</div>
</div>
<p>If you now build your project you should see the newly built shared library
object file.</p>
<pre><code class="language-sh">$ ls --tree Android/shared/build/rustJniLibs
Android/shared/build/rustJniLibs
└── android
   └── arm64-v8a
      └── libshared.so
   └── armeabi-v7a
      └── libshared.so
   └── x86
      └── libshared.so
   └── x86_64
      └── libshared.so
</code></pre>
<p>You should also see the generated types — note that the <code>sourceSets</code> directive
in the shared library gradle file (above) allows us to build our shared library
against the generated types in the <code>shared_types/generated</code> folder.</p>
<pre><code class="language-sh">$ ls --tree shared_types/generated/java
shared_types/generated/java
└── com
   ├── example
   │  └── simple_counter
   │     ├── shared
   │     │  └── shared.kt
   │     └── shared_types
   │        ├── Effect.java
   │        ├── Event.java
   │        ├── RenderOperation.java
   │        ├── Request.java
   │        ├── Requests.java
   │        ├── TraitHelpers.java
   │        └── ViewModel.java
   └── novi
      ├── bincode
      │  ├── BincodeDeserializer.java
      │  └── BincodeSerializer.java
      └── serde
         ├── ArrayLen.java
         ├── BinaryDeserializer.java
         ├── BinarySerializer.java
         ├── Bytes.java
         ├── DeserializationError.java
         ├── Deserializer.java
         ├── Int128.java
         ├── SerializationError.java
         ├── Serializer.java
         ├── Slice.java
         ├── Tuple2.java
         ├── Tuple3.java
         ├── Tuple4.java
         ├── Tuple5.java
         ├── Tuple6.java
         ├── Unit.java
         └── Unsigned.java
</code></pre>
<h2 id="create-some-ui-and-run-in-the-simulator"><a class="header" href="#create-some-ui-and-run-in-the-simulator">Create some UI and run in the Simulator</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-example"></a>
</div>
<div>
<p>There is a slightly more advanced
<a href="https://github.com/redbadger/crux/tree/master/examples/counter">example</a> of an
Android app in the Crux repository.</p>
<p>However, we will use the
<a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter">simple counter example</a>,
which has <code>shared</code> and <code>shared_types</code> libraries that will work with the
following example code.</p>
</div>
</div>
<h3 id="simple-counter-example-2"><a class="header" href="#simple-counter-example-2">Simple counter example</a></h3>
<p>A simple app that increments, decrements and resets a counter.</p>
<h4 id="wrap-the-core-to-support-capabilities-2"><a class="header" href="#wrap-the-core-to-support-capabilities-2">Wrap the core to support capabilities</a></h4>
<p>First, let's add some boilerplate code to wrap our core and handle the
capabilities that we are using. For this example, we only need to support the
<code>Render</code> capability, which triggers a render of the UI.</p>
<p>Let's create a file "<strong>File, New, Kotlin Class/File, File</strong>" called <code>Core</code>.</p>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-note-2"></a>
</div>
<div>
<p>This code that wraps the core only needs to be written once — it only grows when
we need to support additional capabilities.</p>
</div>
</div>
<p>Edit <code>Android/app/src/main/java/com/example/simple_counter/Core.kt</code> to look like
the following. This code sends our (UI-generated) events to the core, and
handles any effects that the core asks for. In this simple example, we aren't
calling any HTTP APIs or handling any side effects other than rendering the UI,
so we just handle this render effect by updating the published view model from
the core.</p>
<pre><code class="language-swift">package com.example.simple_counter

import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import com.example.simple_counter.shared.processEvent
import com.example.simple_counter.shared.view
import com.example.simple_counter.shared_types.Effect
import com.example.simple_counter.shared_types.Event
import com.example.simple_counter.shared_types.Request
import com.example.simple_counter.shared_types.Requests
import com.example.simple_counter.shared_types.ViewModel

class Core : androidx.lifecycle.ViewModel() {
    var view: ViewModel? by mutableStateOf(null)
        private set

    fun update(event: Event) {
        val effects = processEvent(event.bincodeSerialize())

        val requests = Requests.bincodeDeserialize(effects)
        for (request in requests) {
            processEffect(request)
        }
    }

    private fun processEffect(request: Request) {
        when (request.effect) {
            is Effect.Render -&gt; {
                this.view = ViewModel.bincodeDeserialize(view())
            }
        }
    }
}
</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-tip-1"></a>
</div>
<div>
<p>That <code>when</code> statement, above, is where you would handle any other effects that
your core might ask for. For example, if your core needs to make an HTTP
request, you would handle that here. To see an example of this, take a look at
the
<a href="https://github.com/redbadger/crux/tree/master/examples/counter/iOS/CounterApp/core.swift">counter example</a>
in the Crux repository.</p>
</div>
</div>
<p>Edit <code>/Android/app/src/main/java/com/example/simple_counter/MainActivity.kt</code> to
look like the following:</p>
<pre><code class="language-kotlin">package com.example.simple_counter

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.simple_counter.shared_types.Event
import com.example.simple_counter.ui.theme.SimpleCounterTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            SimpleCounterTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background
                ) {
                    View()
                }
            }
        }
    }
}

@Composable
fun View(core: Core = viewModel()) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier
            .fillMaxSize()
            .padding(10.dp),
    ) {
        Text(text = (core.view?.count ?: "0").toString(), modifier = Modifier.padding(10.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(10.dp)) {
            Button(
                onClick = { core.update(Event.Reset()) }, colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.error
                )
            ) { Text(text = "Reset", color = Color.White) }
            Button(
                onClick = { core.update(Event.Increment()) }, colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.primary
                )
            ) { Text(text = "Increment", color = Color.White) }
            Button(
                onClick = { core.update(Event.Decrement()) }, colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.secondary
                )
            ) { Text(text = "Decrement", color = Color.White) }
        }
    }
}

@Preview(showBackground = true)
@Composable
fun DefaultPreview() {
    SimpleCounterTheme {
        View()
    }
}
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/Android/android.html#admonition-success"></a>
</div>
<div>
<p>You should then be able to run the app in the simulator, and it should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/Android/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web"><a class="header" href="#web">Web</a></h1>
<p>When we use Crux to build Web apps, the shared core is compiled to WebAssembly.
This has the advantage of sandboxing the core, physically preventing it from
performing any side-effects (which is conveniently one of the main goals of Crux
anyway!). The invariants of Crux are actually enforced by the WebAssembly
runtime.</p>
<p>We <em>do</em> have to decide how much of our app we want to include in the WebAssembly
binary, though. Typically, if we are writing our UI in TypeScript (or
JavaScript) we would just compile our shared behavior and the Crux Core to
WebAssembly. However, if we are writing our UI in Rust we can compile the entire
app to WebAssembly.</p>
<h2 id="web-apps-with-typescript-ui"><a class="header" href="#web-apps-with-typescript-ui">Web apps with TypeScript UI</a></h2>
<p>When building UI with React, or any other JS/TS framework, the Core API bindings
are generated in TypeScript using Mozilla's
<a href="https://mozilla.github.io/uniffi-rs/">Uniffi</a>, and, just like with Android and
iOS we must serialize and deserialize the messages into and out of the
WebAssembly binary.</p>
<p>The shared core (that contains our app's behavior) is compiled to a WebAssembly
binary, using <a href="https://rustwasm.github.io/wasm-pack/"><code>wasm-pack</code></a>, which
creates an npm package for us that we can add to our project just like any other
npm package.</p>
<p>The shared types are also generated by Crux as a TypeScript npm package, which
we can add in the same way (e.g. with <code>pnpm add</code>).</p>
<p><img src="getting_started/web/./flow_ts.svg" alt="build flow" /></p>
<p>This section has two guides for building TypeScript UI with Crux:</p>
<ol>
<li><a href="getting_started/web/./nextjs.html">TypeScript and React (Next.js)</a></li>
<li><a href="getting_started/web/./remix.html">TypeScript and React (Remix)</a></li>
<li><a href="getting_started/web/./svelte.html">TypeScript and Svelte (Parcel)</a></li>
</ol>
<h2 id="web-apps-with-rust-ui"><a class="header" href="#web-apps-with-rust-ui">Web apps with Rust UI</a></h2>
<p>When building UI with Rust, we can compile the entire app to WebAssembly, and
reference the core and the <code>shared</code> crate directly. We do not have to serialize
and deserialize messages, because the messages stay in the same memory space.</p>
<p>The shared core (that contains our app's behavior) <em>and</em> the UI code are
compiled to a WebAssembly binary, using the relevant toolchain for the language
and framework we are using. We use <a href="https://trunkrs.dev/"><code>trunk</code></a> for the Yew
and Leptos guides and <a href="https://dioxuslabs.com/learn/0.4/CLI/installation/"><code>dx</code></a>
for the Dioxus guide.</p>
<p>When using Rust throughout, we can simply use Cargo to add the <code>shared</code> crate
directly to our app.</p>
<p><img src="getting_started/web/./flow_rust.svg" alt="build flow" /></p>
<p>This section has three guides for building Rust UI with Crux:</p>
<ol>
<li><a href="getting_started/web/./yew.html">Rust and Yew</a></li>
<li><a href="getting_started/web/./leptos.html">Rust and Leptos</a></li>
<li><a href="getting_started/web/./dioxus.html">Rust and Dioxus</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web--typescript-and-react-nextjs"><a class="header" href="#web--typescript-and-react-nextjs">Web — TypeScript and React (Next.js)</a></h1>
<p>These are the steps to set up and run a simple TypeScript Web app that calls
into a shared core.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/nextjs.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code> libraries to your repo, as described in <a href="getting_started/web/../core.html">Shared core and types</a>.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/nextjs.html#admonition-info"></a>
</div>
<div>
<p>There are many frameworks available for writing Web applications with JavaScript/TypeScript. We've chosen <a href="https://reactjs.org/">React</a> with <a href="https://nextjs.org/">Next.js</a> for this walk-through because it is simple and popular. However, a similar setup would work for other frameworks.</p>
</div>
</div>
<h2 id="create-a-nextjs-app"><a class="header" href="#create-a-nextjs-app">Create a Next.js App</a></h2>
<p>For this walk-through, we'll use the <a href="https://pnpm.io/"><code>pnpm</code></a> package manager
for no reason other than we like it the most!</p>
<p>Let's create a simple Next.js app for TypeScript, using <code>pnpx</code> (from <code>pnpm</code>).
You can probably accept the defaults.</p>
<pre><code class="language-sh">pnpx create-next-app@latest
</code></pre>
<h2 id="compile-our-rust-shared-library-2"><a class="header" href="#compile-our-rust-shared-library-2">Compile our Rust shared library</a></h2>
<p>When we build our app, we also want to compile the Rust core to WebAssembly so
that it can be referenced from our code.</p>
<p>To do this, we'll use
<a href="https://rustwasm.github.io/wasm-pack/installer/"><code>wasm-pack</code></a>, which you can
install like this:</p>
<pre><code class="language-sh"># with homebrew
brew install wasm-pack

# or directly
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
</code></pre>
<p>Now that we have <code>wasm-pack</code> installed, we can build our <code>shared</code> library to
WebAssembly for the browser.</p>
<pre><code class="language-sh">(cd shared &amp;&amp; wasm-pack build --target web)
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/nextjs.html#admonition-tip"></a>
</div>
<div>
<p>You might want to add a <code>wasm:build</code> script to your <code>package.json</code>
file, and call it when you build your nextjs project.</p>
<pre><code class="language-json">{
  "scripts": {
    "build": "pnpm run wasm:build &amp;&amp; next build",
    "dev": "pnpm run wasm:build &amp;&amp; next dev",
    "wasm:build": "cd ../shared &amp;&amp; wasm-pack build --target web"
  }
}
</code></pre>
</div>
</div>
<p>Add the <code>shared</code> library as a Wasm package to your <code>web-nextjs</code> project</p>
<pre><code class="language-sh">cd web-nextjs
pnpm add ../shared/pkg
</code></pre>
<h2 id="add-the-shared-types-1"><a class="header" href="#add-the-shared-types-1">Add the Shared Types</a></h2>
<p>To generate the shared types for TypeScript, we can just run <code>cargo build</code> from
the root of our repository. You can check that they have been generated
correctly:</p>
<pre><code class="language-sh">ls --tree shared_types/generated/typescript
shared_types/generated/typescript
├── bincode
│  ├── bincodeDeserializer.d.ts
│  ├── bincodeDeserializer.js
│  ├── bincodeDeserializer.ts
│  ├── bincodeSerializer.d.ts
│  ├── bincodeSerializer.js
│  ├── bincodeSerializer.ts
│  ├── mod.d.ts
│  ├── mod.js
│  └── mod.ts
├── node_modules
│  └── typescript -&gt; .pnpm/typescript@4.8.4/node_modules/typescript
├── package.json
├── pnpm-lock.yaml
├── serde
│  ├── binaryDeserializer.d.ts
│  ├── binaryDeserializer.js
│  ├── binaryDeserializer.ts
│  ├── binarySerializer.d.ts
│  ├── binarySerializer.js
│  ├── binarySerializer.ts
│  ├── deserializer.d.ts
│  ├── deserializer.js
│  ├── deserializer.ts
│  ├── mod.d.ts
│  ├── mod.js
│  ├── mod.ts
│  ├── serializer.d.ts
│  ├── serializer.js
│  ├── serializer.ts
│  ├── types.d.ts
│  ├── types.js
│  └── types.ts
├── tsconfig.json
└── types
   ├── shared_types.d.ts
   ├── shared_types.js
   └── shared_types.ts
</code></pre>
<p>You can see that it also generates an <code>npm</code> package that we can add directly to
our project.</p>
<pre><code class="language-sh">pnpm add ../shared_types/generated/typescript
</code></pre>
<h2 id="create-some-ui"><a class="header" href="#create-some-ui">Create some UI</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/nextjs.html#admonition-example"></a>
</div>
<div>
<p>There are other, more advanced, <a href="https://github.com/redbadger/crux/tree/master/examples">examples</a> of Next.js apps in the Crux repository.</p>
<p>However, we will use the <a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter">simple counter example</a>, which has <code>shared</code> and <code>shared_types</code> libraries that will work with the following example code.</p>
</div>
</div>
<h3 id="simple-counter-example-3"><a class="header" href="#simple-counter-example-3">Simple counter example</a></h3>
<p>A simple app that increments, decrements and resets a counter.</p>
<h4 id="wrap-the-core-to-support-capabilities-3"><a class="header" href="#wrap-the-core-to-support-capabilities-3">Wrap the core to support capabilities</a></h4>
<p>First, let's add some boilerplate code to wrap our core and handle the
capabilities that we are using. For this example, we only need to support the
<code>Render</code> capability, which triggers a render of the UI.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/nextjs.html#admonition-note-1"></a>
</div>
<div>
<p>This code that wraps the core only needs to be written once — it only grows when
we need to support additional capabilities.</p>
</div>
</div>
<p>Edit <code>src/app/core.ts</code> to look like the following. This code sends our
(UI-generated) events to the core, and handles any effects that the core asks
for. In this simple example, we aren't calling any HTTP APIs or handling any
side effects other than rendering the UI, so we just handle this render effect
by updating the component's <code>view</code> hook with the core's ViewModel.</p>
<p>Notice that we have to serialize and deserialize the data that we pass between
the core and the shell. This is because the core is running in a separate
WebAssembly instance, and so we can't just pass the data directly.</p>
<pre><code class="language-typescript">import type { Dispatch, SetStateAction } from "react";

import { process_event, view } from "shared/shared";
import type { Effect, Event } from "shared_types/types/shared_types";
import {
  EffectVariantRender,
  ViewModel,
  Request,
} from "shared_types/types/shared_types";
import {
  BincodeSerializer,
  BincodeDeserializer,
} from "shared_types/bincode/mod";

export function update(
  event: Event,
  callback: Dispatch&lt;SetStateAction&lt;ViewModel&gt;&gt;,
) {
  console.log("event", event);

  const serializer = new BincodeSerializer();
  event.serialize(serializer);

  const effects = process_event(serializer.getBytes());

  const requests = deserializeRequests(effects);
  for (const { id, effect } of requests) {
    processEffect(id, effect, callback);
  }
}

function processEffect(
  _id: number,
  effect: Effect,
  callback: Dispatch&lt;SetStateAction&lt;ViewModel&gt;&gt;,
) {
  console.log("effect", effect);

  switch (effect.constructor) {
    case EffectVariantRender: {
      callback(deserializeView(view()));
      break;
    }
  }
}

function deserializeRequests(bytes: Uint8Array): Request[] {
  const deserializer = new BincodeDeserializer(bytes);
  const len = deserializer.deserializeLen();
  const requests: Request[] = [];
  for (let i = 0; i &lt; len; i++) {
    const request = Request.deserialize(deserializer);
    requests.push(request);
  }
  return requests;
}

function deserializeView(bytes: Uint8Array): ViewModel {
  return ViewModel.deserialize(new BincodeDeserializer(bytes));
}
</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/nextjs.html#admonition-tip-1"></a>
</div>
<div>
<p>That <code>switch</code> statement, above, is where you would handle any other effects that
your core might ask for. For example, if your core needs to make an HTTP
request, you would handle that here. To see an example of this, take a look at
the
<a href="https://github.com/redbadger/crux/tree/master/examples/counter/web-nextjs/src/core.rs">counter example</a>
in the Crux repository.</p>
</div>
</div>
<h4 id="create-a-component-to-render-the-ui"><a class="header" href="#create-a-component-to-render-the-ui">Create a component to render the UI</a></h4>
<p>Edit <code>src/app/page.tsx</code> to look like the following. This code loads the
WebAssembly core and sends it an initial event. Notice that we pass the
<code>setState</code> hook to the update function so that we can update the state in
response to a render effect from the core.</p>
<pre><code class="language-typescript">"use client";

import type { NextPage } from "next";
import Head from "next/head";
import { useEffect, useRef, useState } from "react";

import init_core from "shared/shared";
import {
  ViewModel,
  EventVariantReset,
  EventVariantIncrement,
  EventVariantDecrement,
} from "shared_types/types/shared_types";

import { update } from "./core";

const Home: NextPage = () =&gt; {
  const [view, setView] = useState(new ViewModel("0"));

  const initialized = useRef(false);
  useEffect(
    () =&gt; {
      if (!initialized.current) {
        initialized.current = true;

        init_core().then(() =&gt; {
          // Initial event
          update(new EventVariantReset(), setView);
        });
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    /*once*/ []
  );

  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Next.js Counter&lt;/title&gt;
      &lt;/Head&gt;

      &lt;main&gt;
        &lt;section className="box container has-text-centered m-5"&gt;
          &lt;p className="is-size-5"&gt;{view.count}&lt;/p&gt;
          &lt;div className="buttons section is-centered"&gt;
            &lt;button
              className="button is-primary is-danger"
              onClick={() =&gt; update(new EventVariantReset(), setView)}
            &gt;
              {"Reset"}
            &lt;/button&gt;
            &lt;button
              className="button is-primary is-success"
              onClick={() =&gt; update(new EventVariantIncrement(), setView)}
            &gt;
              {"Increment"}
            &lt;/button&gt;
            &lt;button
              className="button is-primary is-warning"
              onClick={() =&gt; update(new EventVariantDecrement(), setView)}
            &gt;
              {"Decrement"}
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/section&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
};

export default Home;
</code></pre>
<p>Now all we need is some CSS. First add the <code>Bulma</code> package, and then import it
in <code>layout.tsx</code>.</p>
<pre><code class="language-bash">pnpm add bulma
</code></pre>
<pre><code class="language-typescript">import "bulma/css/bulma.css";
import type { Metadata } from "next";
import { Inter } from "next/font/google";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Crux Simple Counter Example",
  description: "Rust Core, TypeScript Shell (NextJS)",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    &lt;html lang="en"&gt;
      &lt;body className={inter.className}&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<h2 id="build-and-serve-our-app"><a class="header" href="#build-and-serve-our-app">Build and serve our app</a></h2>
<p>We can build our app, and serve it for the browser, in one simple step.</p>
<pre><code class="language-sh">pnpm dev
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/nextjs.html#admonition-success"></a>
</div>
<div>
<p>Your app should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/web/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web--typescript-and-react-remix"><a class="header" href="#web--typescript-and-react-remix">Web — TypeScript and React (Remix)</a></h1>
<p>These are the steps to set up and run a simple TypeScript Web app that calls
into a shared core.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/remix.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code> libraries to your repo, as described in <a href="getting_started/web/../core.html">Shared core and types</a>.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/remix.html#admonition-info"></a>
</div>
<div>
<p>There are many frameworks available for writing Web applications with JavaScript/TypeScript. We've chosen <a href="https://reactjs.org/">React</a> with <a href="https://remix.run/">Remix</a> for this walk-through. However, a similar setup would work for other frameworks.</p>
</div>
</div>
<h2 id="create-a-remix-app"><a class="header" href="#create-a-remix-app">Create a Remix App</a></h2>
<p>For this walk-through, we'll use the <a href="https://pnpm.io/"><code>pnpm</code></a> package manager
for no reason other than we like it the most! You can use <code>npm</code> exactly the same
way, though.</p>
<p>Let's create a simple Remix app for TypeScript, using <code>pnpx</code> (from <code>pnpm</code>). You
can give it a name and then probably accept the defaults.</p>
<pre><code class="language-sh">pnpx create-remix@latest
</code></pre>
<h2 id="compile-our-rust-shared-library-3"><a class="header" href="#compile-our-rust-shared-library-3">Compile our Rust shared library</a></h2>
<p>When we build our app, we also want to compile the Rust core to WebAssembly so
that it can be referenced from our code.</p>
<p>To do this, we'll use
<a href="https://rustwasm.github.io/wasm-pack/installer/"><code>wasm-pack</code></a>, which you can
install like this:</p>
<pre><code class="language-sh"># with homebrew
brew install wasm-pack

# or directly
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
</code></pre>
<p>Now that we have <code>wasm-pack</code> installed, we can build our <code>shared</code> library to
WebAssembly for the browser.</p>
<pre><code class="language-sh">(cd shared &amp;&amp; wasm-pack build --target web)
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/remix.html#admonition-tip"></a>
</div>
<div>
<p>You might want to add a <code>wasm:build</code> script to your <code>package.json</code>
file, and call it when you build your Remix project.</p>
<pre><code class="language-json">{
  "scripts": {
    "build": "pnpm run wasm:build &amp;&amp; remix build",
    "dev": "pnpm run wasm:build &amp;&amp; remix dev",
    "wasm:build": "cd ../shared &amp;&amp; wasm-pack build --target web"
  }
}
</code></pre>
</div>
</div>
<p>Add the <code>shared</code> library as a Wasm package to your <code>web-remix</code> project</p>
<pre><code class="language-sh">cd web-remix
pnpm add ../shared/pkg
</code></pre>
<p>We want to tell the Remix server to bundle our <code>shared</code> Wasm package, so we need
to add a <code>serverDependenciesToBundle</code> key to the object exported in
<code>remix.config.js</code>:</p>
<pre><code class="language-js">/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  ignoredRouteFiles: ["**/.*"],

  // make sure the server bundles our shared library
  serverDependenciesToBundle: [/^shared.*/],

  serverModuleFormat: "cjs",
};
</code></pre>
<h2 id="add-the-shared-types-2"><a class="header" href="#add-the-shared-types-2">Add the Shared Types</a></h2>
<p>To generate the shared types for TypeScript, we can just run <code>cargo build</code> from
the root of our repository. You can check that they have been generated
correctly:</p>
<pre><code class="language-sh">ls --tree shared_types/generated/typescript
shared_types/generated/typescript
├── bincode
│  ├── bincodeDeserializer.d.ts
│  ├── bincodeDeserializer.js
│  ├── bincodeDeserializer.ts
│  ├── bincodeSerializer.d.ts
│  ├── bincodeSerializer.js
│  ├── bincodeSerializer.ts
│  ├── mod.d.ts
│  ├── mod.js
│  └── mod.ts
├── node_modules
│  └── typescript -&gt; .pnpm/typescript@4.8.4/node_modules/typescript
├── package.json
├── pnpm-lock.yaml
├── serde
│  ├── binaryDeserializer.d.ts
│  ├── binaryDeserializer.js
│  ├── binaryDeserializer.ts
│  ├── binarySerializer.d.ts
│  ├── binarySerializer.js
│  ├── binarySerializer.ts
│  ├── deserializer.d.ts
│  ├── deserializer.js
│  ├── deserializer.ts
│  ├── mod.d.ts
│  ├── mod.js
│  ├── mod.ts
│  ├── serializer.d.ts
│  ├── serializer.js
│  ├── serializer.ts
│  ├── types.d.ts
│  ├── types.js
│  └── types.ts
├── tsconfig.json
└── types
   ├── shared_types.d.ts
   ├── shared_types.js
   └── shared_types.ts
</code></pre>
<p>You can see that it also generates an <code>npm</code> package that we can add directly to
our project.</p>
<pre><code class="language-sh">pnpm add ../shared_types/generated/typescript
</code></pre>
<h2 id="load-the-wasm-binary-when-our-remix-app-starts"><a class="header" href="#load-the-wasm-binary-when-our-remix-app-starts">Load the Wasm binary when our Remix app starts</a></h2>
<p>The <code>app/entry.client.tsx</code> file is where we can load our Wasm binary. We can
import the <code>shared</code> package and then call the <code>init</code> function to load the Wasm
binary.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/remix.html#admonition-note-1"></a>
</div>
<div>
<p>Note that we <code>import</code> the wasm binary as well — Remix will automatically bundle
it for us, giving it a cache-friendly hash-based name.</p>
</div>
</div>
<pre><code class="language-ts">/**
 * By default, Remix will handle hydrating your app on the client for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.client
 */

import { RemixBrowser } from "@remix-run/react";
import { startTransition, StrictMode } from "react";
import { hydrateRoot } from "react-dom/client";
import init from "shared/shared";
import wasm from "shared/shared_bg.wasm";

init(wasm).then(() =&gt; {
  startTransition(() =&gt; {
    hydrateRoot(
      document,
      &lt;StrictMode&gt;
        &lt;RemixBrowser /&gt;
      &lt;/StrictMode&gt;
    );
  });
});
</code></pre>
<h2 id="create-some-ui-1"><a class="header" href="#create-some-ui-1">Create some UI</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/remix.html#admonition-example"></a>
</div>
<div>
<p>We will use the <a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter">simple counter example</a>, which has <code>shared</code> and <code>shared_types</code> libraries that will work with the following example code.</p>
</div>
</div>
<h3 id="simple-counter-example-4"><a class="header" href="#simple-counter-example-4">Simple counter example</a></h3>
<p>A simple app that increments, decrements and resets a counter.</p>
<h4 id="wrap-the-core-to-support-capabilities-4"><a class="header" href="#wrap-the-core-to-support-capabilities-4">Wrap the core to support capabilities</a></h4>
<p>First, let's add some boilerplate code to wrap our core and handle the
capabilities that we are using. For this example, we only need to support the
<code>Render</code> capability, which triggers a render of the UI.</p>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/remix.html#admonition-note-2"></a>
</div>
<div>
<p>This code that wraps the core only needs to be written once — it only grows when
we need to support additional capabilities.</p>
</div>
</div>
<p>Edit <code>app/core.ts</code> to look like the following. This code sends our
(UI-generated) events to the core, and handles any effects that the core asks
for. In this simple example, we aren't calling any HTTP APIs or handling any
side effects other than rendering the UI, so we just handle this render effect
by updating the component's <code>view</code> hook with the core's ViewModel.</p>
<p>Notice that we have to serialize and deserialize the data that we pass between
the core and the shell. This is because the core is running in a separate
WebAssembly instance, and so we can't just pass the data directly.</p>
<pre><code class="language-typescript">import type { Dispatch, SetStateAction } from "react";

import { process_event, view } from "shared/shared";
import type { Effect, Event } from "shared_types/types/shared_types";
import {
  EffectVariantRender,
  ViewModel,
  Request,
} from "shared_types/types/shared_types";
import {
  BincodeSerializer,
  BincodeDeserializer,
} from "shared_types/bincode/mod";

export function update(
  event: Event,
  callback: Dispatch&lt;SetStateAction&lt;ViewModel&gt;&gt;,
) {
  console.log("event", event);

  const serializer = new BincodeSerializer();
  event.serialize(serializer);

  const effects = process_event(serializer.getBytes());

  const requests = deserializeRequests(effects);
  for (const { id, effect } of requests) {
    processEffect(id, effect, callback);
  }
}

function processEffect(
  _id: number,
  effect: Effect,
  callback: Dispatch&lt;SetStateAction&lt;ViewModel&gt;&gt;,
) {
  console.log("effect", effect);

  switch (effect.constructor) {
    case EffectVariantRender: {
      callback(deserializeView(view()));
      break;
    }
  }
}

function deserializeRequests(bytes: Uint8Array): Request[] {
  const deserializer = new BincodeDeserializer(bytes);
  const len = deserializer.deserializeLen();
  const requests: Request[] = [];
  for (let i = 0; i &lt; len; i++) {
    const request = Request.deserialize(deserializer);
    requests.push(request);
  }
  return requests;
}

function deserializeView(bytes: Uint8Array): ViewModel {
  return ViewModel.deserialize(new BincodeDeserializer(bytes));
}
</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/remix.html#admonition-tip-1"></a>
</div>
<div>
<p>That <code>switch</code> statement, above, is where you would handle any other effects that
your core might ask for. For example, if your core needs to make an HTTP
request, you would handle that here. To see an example of this, take a look at
the
<a href="https://github.com/redbadger/crux/tree/master/examples/counter/web-remix/src/core.rs">counter example</a>
in the Crux repository.</p>
</div>
</div>
<h4 id="create-a-component-to-render-the-ui-1"><a class="header" href="#create-a-component-to-render-the-ui-1">Create a component to render the UI</a></h4>
<p>Edit <code>app/routes/_index.tsx</code> to look like the following. Notice that we pass the
<code>setState</code> hook to the update function so that we can update the state in
response to a render effect from the core (as seen above).</p>
<pre><code class="language-typescript">import { useEffect, useRef, useState } from "react";

import {
  ViewModel,
  EventVariantReset,
  EventVariantIncrement,
  EventVariantDecrement,
} from "shared_types/types/shared_types";
import { update } from "../core";

export const meta = () =&gt; {
  return [
    { title: "New Remix App" },
    { name: "description", content: "Welcome to Remix!" },
  ];
};

export default function Index() {
  const [view, setView] = useState(new ViewModel("0"));

  const initialized = useRef(false);

  useEffect(
    () =&gt; {
      if (!initialized.current) {
        initialized.current = true;

        // Initial event
        update(new EventVariantReset(), setView);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    /*once*/ []
  );

  return (
    &lt;main&gt;
      &lt;section className="box container has-text-centered m-5"&gt;
        &lt;p className="is-size-5"&gt;{view.count}&lt;/p&gt;
        &lt;div className="buttons section is-centered"&gt;
          &lt;button
            className="button is-primary is-danger"
            onClick={() =&gt; update(new EventVariantReset(), setView)}
          &gt;
            {"Reset"}
          &lt;/button&gt;
          &lt;button
            className="button is-primary is-success"
            onClick={() =&gt; update(new EventVariantIncrement(), setView)}
          &gt;
            {"Increment"}
          &lt;/button&gt;
          &lt;button
            className="button is-primary is-warning"
            onClick={() =&gt; update(new EventVariantDecrement(), setView)}
          &gt;
            {"Decrement"}
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/section&gt;
    &lt;/main&gt;
  );
}
</code></pre>
<p>Now all we need is some CSS.</p>
<p>To add a CSS stylesheet, we can add it to the <code>Links</code> export in the
<code>app/root.tsx</code> file.</p>
<pre><code class="language-tsx">export const links: LinksFunction = () =&gt; [
  ...(cssBundleHref ? [{ rel: "stylesheet", href: cssBundleHref }] : []),
  {
    rel: "stylesheet",
    href: "https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css",
  },
];
</code></pre>
<h2 id="build-and-serve-our-app-1"><a class="header" href="#build-and-serve-our-app-1">Build and serve our app</a></h2>
<p>We can build our app, and serve it for the browser, in one simple step.</p>
<pre><code class="language-sh">pnpm dev
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/remix.html#admonition-success"></a>
</div>
<div>
<p>Your app should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/web/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web---typescript-and-svelte-parcel"><a class="header" href="#web---typescript-and-svelte-parcel">Web - TypeScript and Svelte (Parcel)</a></h1>
<p>These are the steps to set up and run a simple TypeScript Web app that calls
into a shared core.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/svelte.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code> libraries to your repo, as described in <a href="getting_started/web/../core.html">Shared core and types</a>.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/svelte.html#admonition-info"></a>
</div>
<div>
<p>There are many frameworks available for writing Web applications with JavaScript/TypeScript. We've chosen <a href="https://svelte.dev/">Svelte</a> with <a href="https://parceljs.org/">Parcel</a> for this walk-through. However, a similar setup would work for other frameworks.</p>
</div>
</div>
<h2 id="create-a-svelte-app"><a class="header" href="#create-a-svelte-app">Create a Svelte App</a></h2>
<p>Let's create a new project which we'll call <code>web-svelte</code>:</p>
<pre><code class="language-sh">mkdir web-svelte
cd web-svelte
mkdir src/
</code></pre>
<h2 id="compile-our-rust-shared-library-4"><a class="header" href="#compile-our-rust-shared-library-4">Compile our Rust shared library</a></h2>
<p>When we build our app, we also want to compile the Rust core to WebAssembly so
that it can be referenced from our code.</p>
<p>To do this, we'll use
<a href="https://rustwasm.github.io/wasm-pack/installer/"><code>wasm-pack</code></a>, which you can
install like this:</p>
<pre><code class="language-sh"># with homebrew
brew install wasm-pack

# or directly
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
</code></pre>
<p>Now that we have <code>wasm-pack</code> installed, we can build our <code>shared</code> library to
WebAssembly for the browser.</p>
<pre><code class="language-sh">(cd shared &amp;&amp; wasm-pack build --target web)
</code></pre>
<p>Create a <code>package.json</code> file and add the <code>wasm:build</code> script:</p>
<pre><code class="language-json">"scripts": {
    "wasm:build": "cd ../shared &amp;&amp; wasm-pack build --target web",
    "start": "npm run build &amp;&amp; concurrently -k \"parcel serve src/index.html --port 8080 --hmr-port 1174\" ",
    "build": "pnpm run wasm:build &amp;&amp; parcel build src/index.html",
    "dev": "pnpm run wasm:build &amp;&amp; parcel build src/index.html"
  },
</code></pre>
<p>Also make sure to add the <code>shared</code> and <code>shared_types</code> as local dependencies to
the <code>package.json</code>:</p>
<pre><code class="language-json">  "dependencies": {
    // ...
    "shared": "file:../shared/pkg",
    "shared_types": "file:../shared_types/generated/typescript"
    // ...
  }
</code></pre>
<h4 id="create-an-app-to-render-the-ui"><a class="header" href="#create-an-app-to-render-the-ui">Create an app to render the UI</a></h4>
<p>Create a <code>main.ts</code> file in <code>src/</code>:</p>
<pre><code class="language-typescript">import "reflect-metadata";

import App from "./App.svelte";

document.body.setAttribute("data-app-container", "");

export default new App({ target: document.body });
</code></pre>
<p>This file is the main entry point which instantiates a new <code>App</code> object. The
<code>App</code> object is defined in the <code>App.svelte</code> file:</p>
<pre><code class="language-js">&lt;script lang="ts"&gt;
  import "bulma/css/bulma.css";
  import { onMount } from "svelte";
  import { update } from "./core";
  import view from "./core";
  import {
    EventVariantReset,
    EventVariantIncrement,
    EventVariantDecrement,
  } from "shared_types/types/shared_types";

  onMount(async () =&gt; {
    console.log("mount");
  });
&lt;/script&gt;

&lt;section class="box container has-text-centered m-5"&gt;
  &lt;p class="is-size-5"&gt;{$view.count}&lt;/p&gt;
  &lt;div class="buttons section is-centered"&gt;
    &lt;button
      class="button is-primary is-danger"
      on:click={() =&gt; update(new EventVariantReset())}
    &gt;
      {"Reset"}
    &lt;/button&gt;
    &lt;button
      class="button is-primary is-success"
      on:click={() =&gt; update(new EventVariantIncrement())}
    &gt;
      {"Increment"}
    &lt;/button&gt;
    &lt;button
      class="button is-primary is-warning"
      on:click={() =&gt; update(new EventVariantDecrement())}
    &gt;
      {"Decrement"}
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/section&gt;
</code></pre>
<p>This file implements the UI and the behaviour for various user actions.</p>
<p>In order to serve the Svelte app, create a <code>index.html</code> in <code>src/</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5" /&gt;
  &lt;title&gt;Simple Counter&lt;/title&gt;
  &lt;meta name="apple-mobile-web-app-title" content="Simple Counter" /&gt;
  &lt;meta name="application-name" content="Simple Counter" /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script type="module" src="main.ts"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>This file ensures that the main entry point gets called.</p>
<h4 id="wrap-the-core-to-support-capabilities-5"><a class="header" href="#wrap-the-core-to-support-capabilities-5">Wrap the core to support capabilities</a></h4>
<p>Let's add a file <code>src/core.ts</code> which will wrap our core and handle the
capabilities that we are using.</p>
<pre><code class="language-typescript">import { process_event, view } from "shared";
import initCore from "shared";
import { writable } from "svelte/store";
import {
  EffectVariantRender,
  ViewModel,
  Request,
} from "shared_types/types/shared_types";
import type { Effect, Event } from "shared_types/types/shared_types";
import {
  BincodeSerializer,
  BincodeDeserializer,
} from "shared_types/bincode/mod";

const { subscribe, set } = writable(new ViewModel("0"));

export async function update(event: Event) {
  console.log("event", event);
  await initCore();

  const serializer = new BincodeSerializer();
  event.serialize(serializer);

  const effects = process_event(serializer.getBytes());
  const requests = deserializeRequests(effects);
  for (const { id, effect } of requests) {
    processEffect(id, effect);
  }
}

function processEffect(_id: number, effect: Effect) {
  console.log("effect", effect);
  switch (effect.constructor) {
    case EffectVariantRender: {
      set(deserializeView(view()));
      break;
    }
  }
}

function deserializeRequests(bytes: Uint8Array): Request[] {
  const deserializer = new BincodeDeserializer(bytes);
  const len = deserializer.deserializeLen();
  const requests: Request[] = [];
  for (let i = 0; i &lt; len; i++) {
    const request = Request.deserialize(deserializer);
    requests.push(request);
  }
  return requests;
}

function deserializeView(bytes: Uint8Array): ViewModel {
  return ViewModel.deserialize(new BincodeDeserializer(bytes));
}

export default {
  subscribe,
};
</code></pre>
<p>This code sends our (UI-generated) events to the core, and handles any effects
that the core asks for via the <code>update()</code> function. Notice that we are creating
a <a href="https://svelte.dev/docs/svelte-store">store</a> to update and manage the view
model. Whenever <code>update()</code> gets called to send an event to the core, we are
fetching the updated view model via <code>view()</code> and are updating the value in the
store. Svelte components can import and use the store values.</p>
<p>Notice that we have to serialize and deserialize the data that we pass between
the core and the shell. This is because the core is running in a separate
WebAssembly instance, and so we can't just pass the data directly.</p>
<h2 id="build-and-serve-our-app-2"><a class="header" href="#build-and-serve-our-app-2">Build and serve our app</a></h2>
<p>We can build our app, and serve it for the browser, in one simple step.</p>
<pre><code class="language-sh">npm start
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/svelte.html#admonition-success"></a>
</div>
<div>
<p>Your app should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/web/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web--rust-and-yew"><a class="header" href="#web--rust-and-yew">Web — Rust and Yew</a></h1>
<p>These are the steps to set up and run a simple Rust Web app that calls into a
shared core.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/yew.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code> libraries to your repo, as described in <a href="getting_started/web/../core.html">Shared core and types</a>.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/yew.html#admonition-info"></a>
</div>
<div>
<p>There are many frameworks available for writing Web applications in Rust. We've chosen <a href="https://yew.rs/">Yew</a> for this walk-through because it is arguably the most mature. However, a similar setup would work for any framework that compiles to WebAssembly.</p>
</div>
</div>
<h2 id="create-a-yew-app"><a class="header" href="#create-a-yew-app">Create a Yew App</a></h2>
<p>Our Yew app is just a new Rust project, which we can create with Cargo. For this
example we'll call it <code>web-yew</code>.</p>
<pre><code class="language-sh">cargo new web-yew
</code></pre>
<p>We'll also want to add this new project to our Cargo workspace, by editing the
root <code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">[workspace]
members = ["shared", "web-yew"]
</code></pre>
<p>Now we can start fleshing out our project. Let's add some dependencies to
<code>web-yew/Cargo.toml</code>.</p>
<pre><code class="language-toml">[package]
name = "web-yew"
version = "0.1.0"
edition = "2021"

[dependencies]
shared = { path = "../shared" }
yew = { version = "0.21.0", features = ["csr"] }
</code></pre>
<p>We'll also need a file called <code>index.html</code>, to serve our app.</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
        &lt;title&gt;Yew Counter&lt;/title&gt;
        &lt;link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"
        /&gt;
        &lt;link data-trunk rel="rust" /&gt;
    &lt;/head&gt;
&lt;/html&gt;
</code></pre>
<h2 id="create-some-ui-2"><a class="header" href="#create-some-ui-2">Create some UI</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/yew.html#admonition-example"></a>
</div>
<div>
<p>There are several, more advanced,
<a href="https://github.com/redbadger/crux/tree/master/examples">examples</a> of Yew apps
in the Crux repository.</p>
<p>However, we will use the
<a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter">simple counter example</a>,
which has <code>shared</code> and <code>shared_types</code> libraries that will work with the
following example code.</p>
</div>
</div>
<h3 id="simple-counter-example-5"><a class="header" href="#simple-counter-example-5">Simple counter example</a></h3>
<p>A simple app that increments, decrements and resets a counter.</p>
<h4 id="wrap-the-core-to-support-capabilities-6"><a class="header" href="#wrap-the-core-to-support-capabilities-6">Wrap the core to support capabilities</a></h4>
<p>First, let's add some boilerplate code to wrap our core and handle the
capabilities that we are using. For this example, we only need to support the
<code>Render</code> capability, which triggers a render of the UI.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/yew.html#admonition-note-1"></a>
</div>
<div>
<p>This code that wraps the core only needs to be written once — it only grows when
we need to support additional capabilities.</p>
</div>
</div>
<p>Edit <code>src/core.rs</code> to look like the following. This code sends our
(UI-generated) events to the core, and handles any effects that the core asks
for. In this simple example, we aren't calling any HTTP APIs or handling any
side effects other than rendering the UI, so we just handle this render effect
by sending it directly back to the Yew component. Note that we wrap the effect
in a Message enum because Yew components have a single associated type for
messages and we need that to include both the events that the UI raises (to send
to the core) and the effects that the core uses to request side effects from the
shell.</p>
<p>Also note that because both our core and our shell are written in Rust (and run
in the same memory space), we do not need to serialize and deserialize the data
that we pass between them. We can just pass the data directly.</p>
<pre><code class="language-rust noplayground">use shared::{Counter, Effect, Event};
use std::rc::Rc;
use yew::Callback;

pub type Core = Rc&lt;shared::Core&lt;Effect, Counter&gt;&gt;;

pub enum Message {
    Event(Event),
    #[allow(dead_code)]
    Effect(Effect),
}

pub fn new() -&gt; Core {
    Rc::new(shared::Core::new())
}

pub fn update(core: &amp;Core, event: Event, callback: &amp;Callback&lt;Message&gt;) {
    for effect in core.process_event(event) {
        process_effect(core, effect, callback);
    }
}

pub fn process_effect(_core: &amp;Core, effect: Effect, callback: &amp;Callback&lt;Message&gt;) {
    match effect {
        render @ Effect::Render(_) =&gt; callback.emit(Message::Effect(render)),
    }
}</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/yew.html#admonition-tip"></a>
</div>
<div>
<p>That <code>match</code> statement, above, is where you would handle any other effects that
your core might ask for. For example, if your core needs to make an HTTP
request, you would handle that here. To see an example of this, take a look at
the
<a href="https://github.com/redbadger/crux/tree/master/examples/counter/web-yew/src/core.rs">counter example</a>
in the Crux repository.</p>
</div>
</div>
<p>Edit <code>src/main.rs</code> to look like the following. The <code>update</code> function is
interesting here. We set up a <code>Callback</code> to receive messages from the core and
feed them back into Yew's event loop. Then we test to see if the incoming
message is an <code>Event</code> (raised by UI interaction) and if so we use it to update
the core, returning false to indicate that the re-render will happen later. In
this app, we can assume that any other message is a render <code>Effect</code> and so we
return true indicating to Yew that we <em>do</em> want to re-render.</p>
<pre><code class="language-rust noplayground">mod core;

use crate::core::{Core, Message};
use shared::Event;
use yew::prelude::*;

#[derive(Default)]
struct RootComponent {
    core: Core,
}

impl Component for RootComponent {
    type Message = Message;
    type Properties = ();

    fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
        Self { core: core::new() }
    }

    fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
        let link = ctx.link().clone();
        let callback = Callback::from(move |msg| {
            link.send_message(msg);
        });
        if let Message::Event(event) = msg {
            core::update(&amp;self.core, event, &amp;callback);
            false
        } else {
            true
        }
    }

    fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
        let link = ctx.link();
        let view = self.core.view();

        html! {
            &lt;section class="box container has-text-centered m-5"&gt;
                &lt;p class="is-size-5"&gt;{&amp;view.count}&lt;/p&gt;
                &lt;div class="buttons section is-centered"&gt;
                    &lt;button class="button is-primary is-danger"
                        onclick={link.callback(|_| Message::Event(Event::Reset))}&gt;
                        {"Reset"}
                    &lt;/button&gt;
                    &lt;button class="button is-primary is-success"
                        onclick={link.callback(|_| Message::Event(Event::Increment))}&gt;
                        {"Increment"}
                    &lt;/button&gt;
                    &lt;button class="button is-primary is-warning"
                        onclick={link.callback(|_| Message::Event(Event::Decrement))}&gt;
                        {"Decrement"}
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/section&gt;
        }
    }
}

fn main() {
    yew::Renderer::&lt;RootComponent&gt;::new().render();
}</code></pre>
<h2 id="build-and-serve-our-app-3"><a class="header" href="#build-and-serve-our-app-3">Build and serve our app</a></h2>
<p>The easiest way to compile the app to WebAssembly and serve it in our web page
is to use <a href="https://trunkrs.dev/"><code>trunk</code></a>, which we can install with
<a href="https://brew.sh/">Homebrew</a> (<code>brew install trunk</code>) or Cargo
(<code>cargo install trunk</code>).</p>
<p>We can build our app, serve it and open it in our browser, in one simple step.</p>
<pre><code class="language-sh">trunk serve --open
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/yew.html#admonition-success"></a>
</div>
<div>
<p>Your app should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/web/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web--rust-and-leptos"><a class="header" href="#web--rust-and-leptos">Web — Rust and Leptos</a></h1>
<p>These are the steps to set up and run a simple Rust Web app that calls into a
shared core.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/leptos.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code> libraries to your repo, as described in <a href="getting_started/web/../core.html">Shared core and types</a>.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/leptos.html#admonition-info"></a>
</div>
<div>
<p>There are many frameworks available for writing Web applications in Rust. Here we're choosing <a href="https://leptos.dev/">Leptos</a> for this walk-through as a way to demonstrate how Crux can work with web frameworks that use fine-grained reactivity rather than the conceptual full re-rendering of React. However, a similar setup would work for other frameworks that compile to WebAssembly.</p>
</div>
</div>
<h2 id="create-a-leptos-app"><a class="header" href="#create-a-leptos-app">Create a Leptos App</a></h2>
<p>Our Leptos app is just a new Rust project, which we can create with Cargo. For
this example we'll call it <code>web-leptos</code>.</p>
<pre><code class="language-sh">cargo new web-leptos
</code></pre>
<p>We'll also want to add this new project to our Cargo workspace, by editing the
root <code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">[workspace]
members = ["shared", "web-leptos"]
</code></pre>
<p>Now we can <code>cd</code> into the <code>web-leptos</code> directory and start fleshing out our
project. Let's add some dependencies to <code>shared/Cargo.toml</code>.</p>
<pre><code class="language-toml">[package]
name = "web-leptos"
version = "0.1.0"
edition = "2021"

[dependencies]
leptos = { version = "0.6.15", features = ["csr"] }
shared = { path = "../shared" }

[lints.clippy]
empty_docs = "allow"
</code></pre>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/leptos.html#admonition-tip"></a>
</div>
<div>
<p>If using nightly Rust, you can enable the "nightly" feature for Leptos.
When you do this, the signals become functions that can be called directly.</p>
<p>However in our examples we are using the stable channel and so have to use
the <code>get()</code> and <code>update()</code> functions explicitly.</p>
</div>
</div>
<p>We'll also need a file called <code>index.html</code>, to serve our app.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;title&gt;Leptos Counter&lt;/title&gt;
    &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"&gt;
  &lt;/head&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="create-some-ui-3"><a class="header" href="#create-some-ui-3">Create some UI</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/leptos.html#admonition-example"></a>
</div>
<div>
<p>There is slightly more advanced
<a href="https://github.com/redbadger/crux/tree/master/examples/counter">example</a> of a
Leptos app in the Crux repository.</p>
<p>However, we will use the
<a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter">simple counter example</a>,
which has <code>shared</code> and <code>shared_types</code> libraries that will work with the
following example code.</p>
</div>
</div>
<h3 id="simple-counter-example-6"><a class="header" href="#simple-counter-example-6">Simple counter example</a></h3>
<p>A simple app that increments, decrements and resets a counter.</p>
<h4 id="wrap-the-core-to-support-capabilities-7"><a class="header" href="#wrap-the-core-to-support-capabilities-7">Wrap the core to support capabilities</a></h4>
<p>First, let's add some boilerplate code to wrap our core and handle the
capabilities that we are using. For this example, we only need to support the
<code>Render</code> capability, which triggers a render of the UI.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/leptos.html#admonition-note-1"></a>
</div>
<div>
<p>This code that wraps the core only needs to be written once — it only grows when
we need to support additional capabilities.</p>
</div>
</div>
<p>Edit <code>src/core.rs</code> to look like the following. This code sends our
(UI-generated) events to the core, and handles any effects that the core asks
for. In this simple example, we aren't calling any HTTP APIs or handling any
side effects other than rendering the UI, so we just handle this render effect
by sending the new ViewModel to the relevant Leptos signal.</p>
<p>Also note that because both our core and our shell are written in Rust (and run
in the same memory space), we do not need to serialize and deserialize the data
that we pass between them. We can just pass the data directly.</p>
<pre><code class="language-rust noplayground">use std::rc::Rc;

use leptos::{SignalUpdate, WriteSignal};
use shared::{Counter, Effect, Event, ViewModel};

pub type Core = Rc&lt;shared::Core&lt;Effect, Counter&gt;&gt;;

pub fn new() -&gt; Core {
    Rc::new(shared::Core::new())
}

pub fn update(core: &amp;Core, event: Event, render: WriteSignal&lt;ViewModel&gt;) {
    for effect in core.process_event(event) {
        process_effect(core, effect, render);
    }
}

pub fn process_effect(core: &amp;Core, effect: Effect, render: WriteSignal&lt;ViewModel&gt;) {
    match effect {
        Effect::Render(_) =&gt; {
            render.update(|view| *view = core.view());
        }
    };
}</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/leptos.html#admonition-tip-1"></a>
</div>
<div>
<p>That <code>match</code> statement, above, is where you would handle any other effects that
your core might ask for. For example, if your core needs to make an HTTP
request, you would handle that here. To see an example of this, take a look at
the
<a href="https://github.com/redbadger/crux/tree/master/examples/counter/web-leptos/src/core.rs">counter example</a>
in the Crux repository.</p>
</div>
</div>
<p>Edit <code>src/main.rs</code> to look like the following. This code creates two signals
— one to update the view (which starts off with the core's current view), and
the other to capture events from the UI (which starts of by sending the reset
event). We also create an effect that sends these events into the core whenever
they are raised.</p>
<pre><code class="language-rust noplayground">mod core;

use leptos::{component, create_effect, create_signal, view, IntoView, SignalGet, SignalUpdate};
use shared::Event;

#[component]
fn RootComponent() -&gt; impl IntoView {
    let core = core::new();
    let (view, render) = create_signal(core.view());
    let (event, set_event) = create_signal(Event::Reset);

    create_effect(move |_| {
        core::update(&amp;core, event.get(), render);
    });

    view! {
        &lt;section class="box container has-text-centered m-5"&gt;
            &lt;p class="is-size-5"&gt;{move || view.get().count}&lt;/p&gt;
            &lt;div class="buttons section is-centered"&gt;
                &lt;button class="button is-primary is-danger"
                    on:click=move |_| set_event.update(|value| *value = Event::Reset)
                &gt;
                    {"Reset"}
                &lt;/button&gt;
                &lt;button class="button is-primary is-success"
                    on:click=move |_| set_event.update(|value| *value = Event::Increment)
                &gt;
                    {"Increment"}
                &lt;/button&gt;
                &lt;button class="button is-primary is-warning"
                    on:click=move |_| set_event.update(|value| *value = Event::Decrement)
                &gt;
                    {"Decrement"}
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/section&gt;
    }
}

fn main() {
    leptos::mount_to_body(|| {
        view! { &lt;RootComponent /&gt; }
    });
}</code></pre>
<h2 id="build-and-serve-our-app-4"><a class="header" href="#build-and-serve-our-app-4">Build and serve our app</a></h2>
<p>The easiest way to compile the app to WebAssembly and serve it in our web page
is to use <a href="https://trunkrs.dev/"><code>trunk</code></a>, which we can install with
<a href="https://brew.sh/">Homebrew</a> (<code>brew install trunk</code>) or Cargo
(<code>cargo install trunk</code>).</p>
<p>We can build our app, serve it and open it in our browser, in one simple step.</p>
<pre><code class="language-sh">trunk serve --open
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/leptos.html#admonition-success"></a>
</div>
<div>
<p>Your app should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/web/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web--rust-and-dioxus"><a class="header" href="#web--rust-and-dioxus">Web — Rust and Dioxus</a></h1>
<p>These are the steps to set up and run a simple Rust Web app that calls into a
shared core.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/dioxus.html#admonition-note"></a>
</div>
<div>
<p>This walk-through assumes you have already added the <code>shared</code> and <code>shared_types</code> libraries to your repo, as described in <a href="getting_started/web/../core.html">Shared core and types</a>.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/dioxus.html#admonition-info"></a>
</div>
<div>
<p>There are many frameworks available for writing Web applications in Rust. We've chosen <a href="https://dioxuslabs.com/">Dioxus</a> for this walk-through. However, a similar setup would work for other frameworks that compile to WebAssembly.</p>
</div>
</div>
<h2 id="create-a-dioxus-app"><a class="header" href="#create-a-dioxus-app">Create a Dioxus App</a></h2>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/dioxus.html#admonition-tip"></a>
</div>
<div>
<p>Dioxus has a CLI tool called <code>dx</code>, which can initialize, build and serve our app.</p>
<pre><code class="language-sh">cargo install dioxus-cli
</code></pre>
<p>Test that the executable is available.</p>
<pre><code class="language-sh">dx --help
</code></pre>
</div>
</div>
<p>Before we create a new app, let's add it to our Cargo workspace (so that the
<code>dx</code> tool won't complain), by editing the root <code>Cargo.toml</code> file.</p>
<p>For this example, we'll call the app <code>web-dioxus</code>.</p>
<pre><code class="language-toml">[workspace]
members = ["shared", "web-dioxus"]
</code></pre>
<p>Now we can create a new Dioxus app. The tool asks for a project name, which
we'll provide as <code>web-dioxus</code>.</p>
<pre><code class="language-sh">dx create

cd web-dioxus
</code></pre>
<p>Now we can start fleshing out our project. Let's add some dependencies to the
project's <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[package]
name = "web-dioxus"
version = "0.1.0"
authors = ["Stuart Harris &lt;stuart.harris@red-badger.com&gt;"]
edition = "2021"

[dependencies]
console_error_panic_hook = "0.1.7"
dioxus = { version = "0.6.0-alpha.3", features = ["web"] }
dioxus-logger = "0.5.1"
futures-util = "0.3.31"
shared = { path = "../shared" }
tracing = "0.1.40"
</code></pre>
<h2 id="create-some-ui-4"><a class="header" href="#create-some-ui-4">Create some UI</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/dioxus.html#admonition-example"></a>
</div>
<div>
<p>There is slightly more advanced <a href="https://github.com/redbadger/crux/tree/master/examples/counter">example</a> of a Dioxus app in the Crux repository.</p>
<p>However, we will use the <a href="https://github.com/redbadger/crux/tree/master/examples/simple_counter">simple counter example</a>, which has <code>shared</code> and <code>shared_types</code> libraries that will work with the following example code.</p>
</div>
</div>
<h3 id="simple-counter-example-7"><a class="header" href="#simple-counter-example-7">Simple counter example</a></h3>
<p>A simple app that increments, decrements and resets a counter.</p>
<h4 id="wrap-the-core-to-support-capabilities-8"><a class="header" href="#wrap-the-core-to-support-capabilities-8">Wrap the core to support capabilities</a></h4>
<p>First, let's add some boilerplate code to wrap our core and handle the
capabilities that we are using. For this example, we only need to support the
<code>Render</code> capability, which triggers a render of the UI.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/dioxus.html#admonition-note-1"></a>
</div>
<div>
<p>This code that wraps the core only needs to be written once — it only grows when
we need to support additional capabilities.</p>
</div>
</div>
<p>Edit <code>src/core.rs</code> to look like the following. This code sends our
(UI-generated) events to the core, and handles any effects that the core asks
for. In this simple example, we aren't calling any HTTP APIs or handling any
side effects other than rendering the UI, so we just handle this render effect
by updating the component's <code>view</code> hook with the core's ViewModel.</p>
<p>Also note that because both our core and our shell are written in Rust (and run
in the same memory space), we do not need to serialize and deserialize the data
that we pass between them. We can just pass the data directly.</p>
<pre><code class="language-rust noplayground">use std::rc::Rc;

use dioxus::{
    prelude::{Signal, UnboundedReceiver},
    signals::Writable,
};
use futures_util::StreamExt;
use shared::{Counter, Effect, Event, ViewModel};
use tracing::debug;

type Core = Rc&lt;shared::Core&lt;Effect, Counter&gt;&gt;;

pub struct CoreService {
    core: Core,
    view: Signal&lt;ViewModel&gt;,
}

impl CoreService {
    pub fn new(view: Signal&lt;ViewModel&gt;) -&gt; Self {
        debug!("initializing core service");
        Self {
            core: Rc::new(shared::Core::new()),
            view,
        }
    }

    pub async fn run(&amp;self, rx: &amp;mut UnboundedReceiver&lt;Event&gt;) {
        let mut view = self.view;
        view.set(self.core.view());
        while let Some(event) = rx.next().await {
            self.update(event, &amp;mut view);
        }
    }

    fn update(&amp;self, event: Event, view: &amp;mut Signal&lt;ViewModel&gt;) {
        debug!("event: {:?}", event);

        for effect in self.core.process_event(event) {
            process_effect(&amp;self.core, effect, view);
        }
    }
}

fn process_effect(core: &amp;Core, effect: Effect, view: &amp;mut Signal&lt;ViewModel&gt;) {
    debug!("effect: {:?}", effect);

    match effect {
        Effect::Render(_) =&gt; {
            view.set(core.view());
        }
    };
}</code></pre>
<div id="admonition-tip-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-1-title">
<div class="admonition-title">
<div id="admonition-tip-1-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/dioxus.html#admonition-tip-1"></a>
</div>
<div>
<p>That <code>match</code> statement, above, is where you would handle any other effects that
your core might ask for. For example, if your core needs to make an HTTP
request, you would handle that here. To see an example of this, take a look at
the
<a href="https://github.com/redbadger/crux/tree/master/examples/counter/web-dioxus/src/core.rs">counter example</a>
in the Crux repository.</p>
</div>
</div>
<p>Edit <code>src/main.rs</code> to look like the following. This code sets up the Dioxus app,
and connects the core to the UI. Not only do we create a hook for the view state
but we also create a coroutine that plugs in the Dioxus "service" we defined
above to constantly send any events from the UI to the core.</p>
<pre><code class="language-rust noplayground">mod core;

use dioxus::prelude::*;
use tracing::Level;

use shared::{Event, ViewModel};

use core::CoreService;

#[component]
fn App() -&gt; Element {
    let view = use_signal(ViewModel::default);

    let core = use_coroutine(move |mut rx| {
        let svc = CoreService::new(view);
        async move { svc.run(&amp;mut rx).await }
    });
    rsx! {
        document::Link {
            rel: "stylesheet",
            href: asset!("./public/css/bulma.min.css")
        }
        main {
            section { class: "section has-text-centered",
                p { class: "is-size-5", "{view().count}" }
                div { class: "buttons section is-centered",
                    button { class:"button is-primary is-danger",
                        onclick: move |_| {
                            core.send(Event::Reset);
                        },
                        "Reset"
                    }
                    button { class:"button is-primary is-success",
                        onclick: move |_| {
                            core.send(Event::Increment);
                        },
                        "Increment"
                    }
                    button { class:"button is-primary is-warning",
                        onclick: move |_| {
                            core.send(Event::Decrement);
                        },
                        "Decrement"
                    }
                }
            }
        }
    }
}

fn main() {
    dioxus_logger::init(Level::DEBUG).expect("failed to init logger");
    console_error_panic_hook::set_once();

    launch(App);
}</code></pre>
<p>We can add a title and a stylesheet by editing
<code>examples/simple_counter/web-dioxus/Dioxus.toml</code>.</p>
<pre><code class="language-toml">[application]
name = "web-dioxus"
default_platform = "web"
out_dir = "dist"
asset_dir = "public"

[web.app]
title = "Crux Simple Counter example"

[web.watcher]
reload_html = true
watch_path = ["src", "public"]
</code></pre>
<h2 id="build-and-serve-our-app-5"><a class="header" href="#build-and-serve-our-app-5">Build and serve our app</a></h2>
<p>Now we can build our app and serve it in one simple step.</p>
<pre><code class="language-sh">dx serve
</code></pre>
<div id="admonition-success" class="admonition admonish-success" role="note" aria-labelledby="admonition-success-title">
<div class="admonition-title">
<div id="admonition-success-title">
<p>Success</p>
</div>
<a class="admonition-anchor-link" href="getting_started/web/dioxus.html#admonition-success"></a>
</div>
<div>
<p>Your app should look like this:</p>
<p align="center"><img alt="simple counter app" src="getting_started/web/./simple_counter.webp"  width="300"></p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h1>
<p>As the first step, we will build a simple application, starting with a classic
Hello World, adding some state, and finally a remote API call. We will focus on
the core, rely on tests to tell us things work, and return to the shell a little
later, so unfortunately there won't be much to see until then.</p>
<p>If you want to follow along, you should start by following the
<a href="guide/../getting_started/core.html">Shared core and types</a>, guide to set up the
project.</p>
<h2 id="creating-an-app"><a class="header" href="#creating-an-app">Creating an app</a></h2>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="guide/hello_world.html#admonition-example"></a>
</div>
<div>
<p>You can find the full code for this part of the guide <a href="https://github.com/redbadger/crux/blob/master/examples/hello_world/shared/src/app.rs">here</a></p>
</div>
</div>
<p>To start with, we need a <code>struct</code> to be the root of our app.</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
pub struct Hello;</code></pre>
<p>We need to implement <code>Default</code> so that Crux can construct the app for us.</p>
<p>To turn it into an app, we need to implement the <code>App</code> trait from the
<code>crux_core</code> crate.</p>
<pre><code class="language-rust noplayground">use crux_core::App;

#[derive(Default)]
pub struct Model;

impl App for Hello {}</code></pre>
<p>If you're following along, the compiler is now screaming at you that you're
missing four associated types for the trait: <code>Event</code>, <code>Model</code>, <code>ViewModel</code> and
<code>Capabilities</code>.</p>
<p>Capabilities is the more complicated of them, and to understand what it does, we
need to talk about what makes Crux different from most UI frameworks.</p>
<h2 id="side-effects-and-capabilities"><a class="header" href="#side-effects-and-capabilities">Side-effects and capabilities</a></h2>
<p>One of the key design choices in Crux is that the Core is free of side-effects
(besides its internal state). Your application can never <em>perform</em> anything that
directly interacts with the environment around it - no network calls, no
reading/writing files, and (somewhat obviously) not even updating the screen.
Actually <em>doing</em> all those things is the job of the Shell, the core can only
<em>ask</em> for them to be done.</p>
<p>This makes the core portable between platforms, and, importantly, really easy to
test. It also separates the intent, the "functional" requirements, from the
implementation of the side-effects and the "non-functional" requirements (NFRs).
For example, your application knows it wants to store data in a SQL database,
but it doesn't need to know or care whether that database is local or remote.
That decision can even change as the application evolves, and be different on
each platform. If you want to understand this better before we carry on, you can
read a lot more about how side-effects work in Crux in the chapter on
<a href="guide/./capabilities.html">capabilities</a>.</p>
<p>To <em>ask</em> the Shell for side effects, it will need to know what side effects it
needs to handle, so we will need to declare them (as an enum). <em>Effects</em> are
simply messages describing what should happen, and for more complex side-effects
(e.g. HTTP), they would be too unwieldy to create by hand, so to help us create
them, Crux provides <em>capabilities</em> - reusable libraries which give us a nice API
for requesting side-effects. We'll look at them in a lot more detail later.</p>
<p>Let's start with the basics:</p>
<pre><code class="language-rust noplayground">use crux_core::render::Render;

pub struct Capabilities {
    render: Render&lt;Event&gt;,
}</code></pre>
<p>As you can see, for now, we will use a single capability, <code>Render</code>, which is
built into Crux and available from the <code>crux_core</code> crate. It simply tells the
shell to update the screen using the latest information.</p>
<p>That means the core can produce a single <code>Effect</code>. It will soon be more than
one, so we'll wrap it in an enum to give ourselves space. The <code>Effect</code> enum
corresponds one to one to the <code>Capabilities</code> we're using, and rather than typing
it (and its associated trait implementations) by hand and open ourselves to
unnecessary mistakes, we can use the <code>crux_core::macros::Effect</code> derive macro.</p>
<pre><code class="language-rust noplayground">use crux_core::render::Render;
use crux_core::macros::Effect;

#[derive(Effect)]
pub struct Capabilities {
    render: Render&lt;Event&gt;,
}</code></pre>
<p>Other than the <code>derive</code> itself, we also need to link the effect to our app.
We'll go into the detail of why that is in the <a href="guide/capabilities.html">Capabilities</a>
section, but the basic reason is that capabilities need to be able to send the
app the outcomes of their work.</p>
<p>You probably also noticed the <code>Event</code> type which capabilities are generic over,
because they need to know the type which defines messages they can send back to
the app. The same type is also used by the Shell to forward any user
interactions to the Core, and in order to pass across the FFI boundary, it needs
to be serializable. The resulting code will end up looking like this:</p>
<pre><code class="language-rust noplayground">use crux_core::{render::Render, App};
use crux_core::macros::Effect;
use serde::{Deserialize, Serialize};

#[cfg_attr(feature = "typegen", derive(crux_core::macros::Export))]
#[derive(Effect)]
pub struct Capabilities {
    render: Render&lt;Event&gt;,
}

#[derive(Serialize, Deserialize)]
pub enum Event {
    None, // we can't instantiate an empty enum, so let's have a dummy variant for now
}

#[derive(Default)]
pub struct Hello;

impl App for Hello { ... }</code></pre>
<p>In this example, we also invoke the <code>Export</code> derive macro, but only when the
<code>typegen</code> feature is enabled — this is true in your <code>shared_types</code> library to
generate the foreign types for the shell. For more detail see the
<a href="guide/../getting_started/core.html#create-the-shared-types-crate">Shared core and types</a>
guide.</p>
<p>Okay, that took a little bit of effort, but with this short detour out of the
way and foundations in place, we can finally create an app and start
implementing some behavior.</p>
<h2 id="implementing-the-app-trait"><a class="header" href="#implementing-the-app-trait">Implementing the <code>App</code> trait</a></h2>
<p>We now have almost all the building blocks to implement the <code>App</code> trait. We're
just missing two simple types. First, a <code>Model</code> to keep our app's state, it
makes sense to make that a struct. It needs to implement <code>Default</code>, which gives
us an opportunity to set up any initial state the app might need. Second, we
need a <code>ViewModel</code>, which is a representation of what the user should see on
screen. It might be tempting to represent the state and the view with the same
type, but in more complicated cases it will be too constraining, and probably
non-obvious what data are for internal bookkeeping and what should end up on
screen, so Crux separates the concepts. Nothing stops you using the same type
for both <code>Model</code> and <code>ViewModel</code> if your app is simple enough.</p>
<p>We'll start with a few simple types for events, model and view model.</p>
<p>Now we can finally implement the trait with its two methods, <code>update</code> and
<code>view</code>.</p>
<pre><code class="language-rust noplayground">
use crux_core::{render::Render, App};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub enum Event {
    None,
}

#[derive(Default)]
pub struct Model;

#[derive(Serialize, Deserialize)]
pub struct ViewModel {
    data: String,
}

#[derive(crux_core::macros::Effect)]
pub struct Capabilities {
    render: Render&lt;Event&gt;,
}

#[derive(Default)]
pub struct Hello;

impl App for Hello {
    type Event = Event;
    type Model = Model;
    type ViewModel = ViewModel;
    type Capabilities = Capabilities;

    fn update(&amp;self, _event: Self::Event, _model: &amp;mut Self::Model, caps: &amp;Self::Capabilities) {
        caps.render.render();
    }

    fn view(&amp;self, _model: &amp;Self::Model) -&gt; Self::ViewModel {
        ViewModel {
            data: "Hello World".to_string(),
        }
    }
}
</code></pre>
<p>The <code>update</code> function is the heart of the app. It responds to events by
(optionally) updating the state and requesting some effects by using the
capability's APIs.</p>
<p>All our <code>update</code> function does is ignore all its arguments and ask the Shell to
render the screen. It's a hello world after all.</p>
<p>The <code>view</code> function returns the representation of what we want the Shell to show
on screen. And true to form, it returns an instance of the <code>ViewModel</code> struct
containing <code>Hello World!</code>.</p>
<p>That's a working hello world done, lets try it. As we said at the beginning, for
now we'll do it from tests. It may sound like a concession, but in fact, this is
the intended way for apps to be developed with Crux - from inside out, with unit
tests, focusing on behavior first and presentation later, roughly corresponding
to doing the user experience first, then the visual design.</p>
<p>Here's our test:</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    use super::*;
    use crux_core::testing::AppTester;

    #[test]
    fn hello_says_hello_world() {
        let hello = AppTester::&lt;Hello, _&gt;::default();
        let mut model = Model;

        // Call 'update' and request effects
        let update = hello.update(Event::None, &amp;mut model);

        // Check update asked us to `Render`
        update.expect_one_effect().expect_render();

        // Make sure the view matches our expectations
        let actual_view = &amp;hello.view(&amp;model).data;
        let expected_view = "Hello World";
        assert_eq!(actual_view, expected_view);
    }
}
</code></pre>
<p>It is a fairly underwhelming test, but it should pass (check with <code>cargo test</code>).
The test uses a testing helper from <code>crux_core::testing</code> that lets us easily
interact with the app, inspect the effects it requests and its state, without
having to set up the machinery every time. It's not exactly complicated, but
it's a fair amount of boiler plate code.</p>
<h2 id="counting-up-and-down"><a class="header" href="#counting-up-and-down">Counting up and down</a></h2>
<div id="admonition-example-1" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-title">
<div class="admonition-title">
<div id="admonition-example-1-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="guide/hello_world.html#admonition-example-1"></a>
</div>
<div>
<p>You can find the full code for this part of the guide
<a href="https://github.com/redbadger/crux/blob/master/examples/simple_counter/shared/src/counter.rs">here</a></p>
</div>
</div>
<p>Let's make things more interesting and add some behaviour. We'll teach the app
to count up and down. First, we'll need a model, which represents the state. We
could just make our model a number, but we'll go with a struct instead, so that
we can easily add more state later.</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
pub struct Model {
    count: isize,
}</code></pre>
<p>We need <code>Default</code> implemented to define the initial state. For now we derive it,
as our state is quite simple. We also update the app to show the current count:</p>
<pre><code class="language-rust noplayground">impl App for Hello {
// ...

    type Model = Model;

// ...

    fn view(&amp;self, model: &amp;Self::Model) -&gt; Self::ViewModel {
        ViewModel {
            count: format!("Count is: {}", model.count),
        }
    }
}</code></pre>
<p>We'll also need a simple <code>ViewModel</code> struct to hold the data that the Shell will
render.</p>
<pre><code class="language-rust noplayground">#[derive(Serialize, Deserialize)]
pub struct ViewModel {
    count: String,
}</code></pre>
<p>Great. All that's left is adding the behaviour. That's where <code>Event</code> comes in:</p>
<pre><code class="language-rust noplayground">#[derive(Serialize, Deserialize)]
pub enum Event {
    Increment,
    Decrement,
    Reset,
}</code></pre>
<p>The event type covers all the possible events the app can respond to. "Will that
not get massive really quickly??" I hear you ask. Don't worry about that, there
is <a href="guide/./composing.html">a nice way to make this scale</a> and get reuse as well. Let's
carry on. We need to actually handle those messages.</p>
<pre><code class="language-rust noplayground">impl App for Counter {
    type Event = Event;
    type Model = Model;
    type ViewModel = ViewModel;
    type Capabilities = Capabilities;

    fn update(&amp;self, event: Self::Event, model: &amp;mut Self::Model, caps: &amp;Self::Capabilities) {
        match event {
            Event::Increment =&gt; model.count += 1,
            Event::Decrement =&gt; model.count -= 1,
            Event::Reset =&gt; model.count = 0,
        };

        caps.render.render();
    }

    fn view(&amp;self, model: &amp;Self::Model) -&gt; Self::ViewModel {
        ViewModel {
            count: format!("Count is: {}", model.count),
        }
    }
}
// ...</code></pre>
<p>Pretty straightforward, we just do what we're told, update the state, and then
tell the Shell to render. Lets update the tests to check everything works as
expected.</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod test {
    use super::*;
    use crux_core::{assert_effect, testing::AppTester};

    #[test]
    fn renders() {
        let app = AppTester::&lt;Counter, _&gt;::default();
        let mut model = Model::default();

        let update = app.update(Event::Reset, &amp;mut model);

        // Check update asked us to `Render`
        assert_effect!(update, Effect::Render(_));
    }

    #[test]
    fn shows_initial_count() {
        let app = AppTester::&lt;Counter, _&gt;::default();
        let model = Model::default();

        let actual_view = app.view(&amp;model).count;
        let expected_view = "Count is: 0";
        assert_eq!(actual_view, expected_view);
    }

    #[test]
    fn increments_count() {
        let app = AppTester::&lt;Counter, _&gt;::default();
        let mut model = Model::default();

        let update = app.update(Event::Increment, &amp;mut model);

        let actual_view = app.view(&amp;model).count;
        let expected_view = "Count is: 1";
        assert_eq!(actual_view, expected_view);

        // Check update asked us to `Render`
        assert_effect!(update, Effect::Render(_));
    }

    #[test]
    fn decrements_count() {
        let app = AppTester::&lt;Counter, _&gt;::default();
        let mut model = Model::default();

        let update = app.update(Event::Decrement, &amp;mut model);

        let actual_view = app.view(&amp;model).count;
        let expected_view = "Count is: -1";
        assert_eq!(actual_view, expected_view);

        // Check update asked us to `Render`
        assert_effect!(update, Effect::Render(_));
    }

    #[test]
    fn resets_count() {
        let app = AppTester::&lt;Counter, _&gt;::default();
        let mut model = Model::default();

        let _ = app.update(Event::Increment, &amp;mut model);
        let _ = app.update(Event::Reset, &amp;mut model);

        let actual_view = app.view(&amp;model).count;
        let expected_view = "Count is: 0";
        assert_eq!(actual_view, expected_view);
    }

    #[test]
    fn counts_up_and_down() {
        let app = AppTester::&lt;Counter, _&gt;::default();
        let mut model = Model::default();

        let _ = app.update(Event::Increment, &amp;mut model);
        let _ = app.update(Event::Reset, &amp;mut model);
        let _ = app.update(Event::Decrement, &amp;mut model);
        let _ = app.update(Event::Increment, &amp;mut model);
        let _ = app.update(Event::Increment, &amp;mut model);

        let actual_view = app.view(&amp;model).count;
        let expected_view = "Count is: 1";
        assert_eq!(actual_view, expected_view);
    }
}</code></pre>
<p>Hopefully those all pass. We are now sure that when we build an actual UI for
this, it will <em>work</em>, and we'll be able to focus on making it looking
delightful.</p>
<p>In more complicated cases, it might be helpful to inspect the <code>model</code> directly.
It's up to you to make the call of which one is more appropriate, in some sense
it's the difference between black-box and white-box testing, so you should
probably be doing both to get the confidence you need that your app is working.</p>
<h2 id="remote-api"><a class="header" href="#remote-api">Remote API</a></h2>
<p>Before we dive into the thinking behind the architecture, let's add one more
feature - a remote API call - to get a better feel for how side-effects and
capabilities work.</p>
<div id="admonition-example-2" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-title">
<div class="admonition-title">
<div id="admonition-example-2-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="guide/hello_world.html#admonition-example-2"></a>
</div>
<div>
<p>You can find the full code for this part of the guide <a href="https://github.com/redbadger/crux/blob/master/examples/counter/shared/src/app.rs">here</a></p>
</div>
</div>
<p>We'll add a simple integration with a counter API we've prepared at
<a href="https://crux-counter.fly.dev">https://crux-counter.fly.dev</a>. All it does is count up an down like our local
counter. It supports three requests</p>
<ul>
<li><code>GET /</code> returns the current count</li>
<li><code>POST /inc</code> increments the counter</li>
<li><code>POST /dec</code> decrements the counter</li>
</ul>
<p>All three API calls return the state of the counter in JSON, which looks
something like this</p>
<pre><code class="language-json">{
  "value": 34,
  "updated_at": 1673265904973
}
</code></pre>
<p>We can represent that with a struct, and we'll need to update the model as well.
We can use Serde for the serialization (deserializing <code>updated_at</code> from
timestamp milliseconds to an option of <code>DateTime</code> using <code>chrono</code>).</p>
<p>We'll also update the count optimistically by keeping track of if/when the
server confirmed it (there are other ways to model these semantics, but let's
keep it straightforward for now).</p>
<pre><code class="language-rust noplayground">use chrono::{DateTime, Utc};
use chrono::serde::ts_milliseconds_option::deserialize as ts_milliseconds_option;

#[derive(Default, Serialize)]
pub struct Model {
    count: Count,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Count {
    value: isize,
    #[serde(deserialize_with = "ts_milliseconds_option")]
    updated_at: Option&lt;DateTime&lt;Utc&gt;&gt;,
}</code></pre>
<p>We also need to update the <code>ViewModel</code> and the <code>view()</code> function to display the
new data.</p>
<pre><code class="language-rust noplayground">#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ViewModel {
    pub text: String,
    pub confirmed: bool,
}

...

fn view(&amp;self, model: &amp;Self::Model) -&gt; Self::ViewModel {
    let suffix = match model.count.updated_at {
        None =&gt; " (pending)".to_string(),
        Some(d) =&gt; format!(" ({d})"),
    };

    Self::ViewModel {
        text: model.count.value.to_string() + &amp;suffix,
        confirmed: model.count.updated_at.is_some(),
    }
}</code></pre>
<p>You can see that the view function caters to two states - the count has not yet
been confirmed (<code>updated_at</code> is <code>None</code>), and having the count confirmed by the
server.</p>
<p>In a real-world app, it's likely that this information would be captured in a
struct rather than converted to string inside the core, so that the UI can
decide how to present it. The date formatting, however, is an example of
something you may want to do consistently across all platforms and keep inside
the Core. When making these choices, think about whose decisions they are, and
do they need to be consistent across platforms or flexible. You will no doubt
get a number of those calls wrong, but that's ok, the type system is here to
help you refactor later and update the shells to work with the changes.</p>
<p>We now have everything in place to update the <code>update</code> function. Let's start
with thinking about the events. The API does not support resetting the counter,
so that variant goes, but we need a new one to kick off fetching the current
state of the counter. The Core itself can't autonomously start anything, it is
always driven by the Shell, either by the user via the UI, or as a result of a
side-effect.</p>
<p>That gives us the following update function, with some placeholders:</p>
<pre><code class="language-rust noplayground">fn update(&amp;self, event: Self::Event, model: &amp;mut Self::Model, caps: &amp;Self::Capabilities) {
    match event {
        Event::Get =&gt; {
            // TODO "GET /"
        }
        Event::Set(_response) =&gt; {
            // TODO Get the data and update the model
            caps.render.render();
        }
        Event::Increment =&gt; {
            // optimistic update
            model.count.value += 1;
            model.count.updated_at = None;
            caps.render.render();

            // real update
            // TODO "POST /inc"
        }
        Event::Decrement =&gt; {
            // optimistic update
            model.count.value -= 1;
            model.count.updated_at = None;
            caps.render.render();

            // real update
            // TODO "POST /dec"
        }
    }
}</code></pre>
<p>To request the respective HTTP calls, we'll use
<a href="https://github.com/redbadger/crux/tree/master/crux_http"><code>crux_http</code></a> the
built-in HTTP client. Since this is the first capability we're using, some
things won't be immediately clear, but we should get there by the end of this
chapter.</p>
<p>The first thing to know is that the HTTP responses will be sent back to the
update function as an event. That's what the <code>Event::Set</code> is for. The <code>Event</code>
type looks as follows:</p>
<pre><code class="language-rust noplayground">#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
pub enum Event {
    // these variants are used by the Shell
    Get,
    Increment,
    Decrement,

    // this variant is private to the Core
    #[serde(skip)]
    Set(crux_http::Result&lt;crux_http::Response&lt;Count&gt;&gt;),
}</code></pre>
<p>We decorate the <code>Set</code> variant with <code>#[serde(skip)]</code> for two reasons: one,
there's currently a technical limitation stopping us easily serializing
<code>crux_http::Response</code>, and two, there's no reason that variant should ever be
sent by the Shell across the FFI boundary, which is the reason for the need to
serialize in the first place — in a way, it is private to the Core.</p>
<p>Finally, let's get rid of those TODOs. We'll need to add crux_http in the
<code>Capabilities</code> type, so that the <code>update</code> function has access to it:</p>
<pre><code class="language-rust noplayground">use crux_http::Http;

#[derive(Effect)]
pub struct Capabilities {
    pub http: Http&lt;Event&gt;,
    pub render: Render&lt;Event&gt;,
}</code></pre>
<p>This may seem like needless boilerplate, but it allows us to only use the
capabilities we need and, more importantly, allow capabilities to be built by
anyone. Later on, we'll also see that Crux apps <a href="guide/composing.html">compose</a>, relying
on each app's <code>Capabilities</code> type to declare its needs, and making sure the
necessary capabilities exist in the parent app.</p>
<p>We can now implement those TODOs, so lets do it.</p>
<pre><code class="language-rust noplayground">const API_URL: &amp;str = "https://crux-counter.fly.dev";

//...

fn update(&amp;self, event: Self::Event, model: &amp;mut Self::Model, caps: &amp;Self::Capabilities) {
        match event {
            Event::Get =&gt; {
                caps.http.get(API_URL).expect_json().send(Event::Set);
            }
            Event::Set(Ok(mut response)) =&gt; {
                let count = response.take_body().unwrap();
                model.count = count;
                caps.render.render();
            }
            Event::Set(Err(_)) =&gt; {
                panic!("Oh no something went wrong");
            }
            Event::Increment =&gt; {
                // optimistic update
                model.count = Count {
                    value: model.count.value + 1,
                    updated_at: None,
                };
                caps.render.render();

                // real update
                let base = Url::parse(API_URL).unwrap();
                let url = base.join("/inc").unwrap();
                caps.http.post(url).expect_json().send(Event::Set);
            }
            Event::Decrement =&gt; {
                // optimistic update
                model.count = Count {
                    value: model.count.value - 1,
                    updated_at: None,
                };
                caps.render.render();

                // real update
                let base = Url::parse(API_URL).unwrap();
                let url = base.join("/dec").unwrap();
                caps.http.post(url).expect_json().send(Event::Set);
            }
        }
    }
</code></pre>
<p>There's a few things of note. The first one is that the <code>.send</code> API at the end
of each chain of calls to <code>crux_http</code> expects a function that wraps its argument
(a <code>Result</code> of a http response) in a variant of <code>Event</code>. Fortunately, enum tuple
variants create just such a function, and we can use it. The way to read the
call is "Send a get request, parse the response as JSON, which should be
deserialized as a <code>Count</code>, and then call me again with <code>Event::Set</code> carrying the
result". Interestingly, we didn't need to specifically mention the <code>Count</code> type,
as the type inference from the <code>Event::Set</code> variant is enough, making it really
easy to read.</p>
<p>The other thing of note is that the capability calls don't block. They queue up
requests to send to the shell and execution continues immediately. The requests
will be sent in the order they were queued and the asynchronous execution is the
job of the shell.</p>
<p>You can find the the complete example, including the shell implementations
<a href="https://github.com/redbadger/crux/blob/master/examples/counter/">in the Crux repo</a>.
It's interesting to take a closer look at the unit tests</p>
<pre><code class="language-rust noplayground">    /// Test that a `Get` event causes the app to fetch the current
    /// counter value from the web API
    #[test]
    fn get_counter() {
        // instantiate our app via the test harness, which gives us access to the model
        let app = AppTester::&lt;App, _&gt;::default();

        // set up our initial model
        let mut model = Model::default();

        // send a `Get` event to the app
        let update = app.update(Event::Get, &amp;mut model);

        // check that the app emitted an HTTP request,
        // capturing the request in the process
        let request = &amp;mut update.expect_one_effect().expect_http();

        // check that the request is a GET to the correct URL
        let actual = request.operation.clone();
        let expected = HttpRequest::get("https://crux-counter.fly.dev/").build();
        assert_eq!(actual, expected);

        // resolve the request with a simulated response from the web API
        let response = HttpResponse::ok()
            .body(r#"{ "value": 1, "updated_at": 1672531200000 }"#)
            .build();
        let update = app
            .resolve(request, HttpResult::Ok(response))
            .expect("an update");

        // check that the app emitted an (internal) event to update the model
        let actual = update.events;
        let expected = vec![Event::Set(Ok(ResponseBuilder::ok()
            .body(Count {
                value: 1,
                updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
            })
            .build()))];
        assert_eq!(actual, expected);
    }

    /// Test that a `Set` event causes the app to update the model
    #[test]
    fn set_counter() {
        // instantiate our app via the test harness, which gives us access to the model
        let app = AppTester::&lt;App, _&gt;::default();

        // set up our initial model
        let mut model = Model::default();

        // send a `Set` event (containing the HTTP response) to the app
        let update = app.update(
            Event::Set(Ok(ResponseBuilder::ok()
                .body(Count {
                    value: 1,
                    updated_at: Some(Utc.with_ymd_and_hms(2023, 1, 1, 0, 0, 0).unwrap()),
                })
                .build())),
            &amp;mut model,
        );

        // check that the app asked the shell to render
        assert_effect!(update, Effect::Render(_));

        // check that the view has been updated correctly
        insta::assert_yaml_snapshot!(app.view(&amp;model), @r###"
        ---
        text: "1 (2023-01-01 00:00:00 UTC)"
        confirmed: true
        "###);
    }</code></pre>
<p>Incidentally, we're using <a href="https://crates.io/crates/insta"><code>insta</code></a> in that last
test to assert that the view model is correct. If you don't know it already,
check it out. The really cool thing is that if the test fails, it shows you a
diff of the actual and expected output, and if you're happy with the new output,
you can accept the change (or not) by running <code>cargo insta review</code> — it will
update the code for you to reflect the change. It's a really nice way to do
snapshot testing, especially for the model and view model.</p>
<p>You can see how easy it is to check that the app is requesting the right side
effects, with the right arguments, and even test a chain of interactions and
make sure the behavior is correct, all without mocking or stubbing anything or
worrying about <code>async</code> code.</p>
<p>In the next chapter, we can put the example into perspective and discuss the
architecture it follows, inspired by Elm.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elm-architecture"><a class="header" href="#elm-architecture">Elm Architecture</a></h1>
<p>Now we've had a bit of a feel for what writing Crux apps is like, we'll add more context to the different components and the overall architecture of Crux apps. The architecture is heavily inspired by <a href="http://elm-lang.org">Elm</a>, and if you'd like to compare, the <a href="https://guide.elm-lang.org/architecture/">Architecture page of their guide</a> is an excellent starting point.</p>
<h2 id="event-sourcing-as-a-model-for-ui"><a class="header" href="#event-sourcing-as-a-model-for-ui">Event Sourcing as a model for UI</a></h2>
<p>User Interface is fundamentally event-driven. Unlike batch or stream processing, all changes in apps with UI are driven by events happening in the outside world, most commonly the user interface itself – the user touching the screen, typing on a keyboard, executing a CLI command, etc. In response, the app changes what's shown on the screen, starts an interaction with the outside world, or both.</p>
<p>The Elm architecture is the simplest way of modeling this pattern in code. User interactions (along with other changes in the outside world, such as time passing) are represented by events, and in response to them, the app updates its internal state represented by a model. The link between them is a simple, pure function which takes the model and the event, and updates the model based on the events. The actual UI on screen is a direct projection of the model. Because there is virtually no other state in the app, the model must contain enough information to decide what should be on screen.</p>
<p>What we're missing is for the app to be able to respond to events from the outside world by changing the outside world. While the app can run computations and keep state, in this simplistic model, it can't read or write files, draw on screen, connect to APIs over the network, etc. It can't perform side-effects. Conceptually, we need to extend the update function to not only mutate the model, but also to emit some side-effects (or just "effects" for short).</p>
<p><img src="guide/../architecture.svg" alt="Logical architecture" /></p>
<p><em>TODO a better picture focusing on the update function</em></p>
<p>This more complete model is a function which takes an event and a model, and produces a new model and optionally some effects. This is still quite a simple and pure function, and is completely predictable, for the same inputs, it will always yield the same outputs, and that is a very important design choice.</p>
<h2 id="ui-effects-and-testability"><a class="header" href="#ui-effects-and-testability">UI, effects and testability</a></h2>
<p>User interface and effects are normally where testing gets very difficult. If the application logic can directly cause changes in the outside world (or input/output — I/O, in computer parlance), the only way to verify the logic completely is to look at the result of those changes. The results, however, are pixels on screen, elements in the DOM, packets going over the network and other complex, difficult to inspect and often short-lived things. The only viable strategy (in this direct scenario) to test them is to take the role of the particular device the app is working with, and pretending to be that device – a practice known as mocking (or stubbing, or faking, depending who you talk to). The APIs used to interact with these things are really complicated though, and even if you emulate them well, tests based on this approach won't be stable against changes in that API. When the API changes, your code <em>and</em> your tests will both have to change, taking any confidence they gave you in the first place with them. What's more, they also differ across platforms. Now we have that problem twice or more times.</p>
<p>The problem is in how apps are normally written (when written in a direct, imperative style). When it comes time to perform an effect, the most straightforward code just performs it straight away. The solution, as usual, is to add indirection. What Crux does (inspired by Elm, Haskell and others) is <strong>separate the intent from the execution</strong>. Crux's effect approach focuses on capturing the intent of the effect, not the specific implementation of executing it. The intent is captured as data to benefit from type checking and from all the tools the language already provides for working with data. The business logic can stay pure, but express all the behaviour: state changes and effects. The intent is also the thing that needs to be tested. We can reasonably afford to trust that the authors of a HTTP client library, for example, have tested it and it does what it promises to do — all we need to check is that we're sending the right requests<sup class="footnote-reference"><a href="#testing">1</a></sup>.</p>
<h2 id="executing-the-effects-the-runtime-shell"><a class="header" href="#executing-the-effects-the-runtime-shell">Executing the effects: the <del>runtime</del> Shell</a></h2>
<p>In Elm, the responsibility to execute the requested effects falls on the Elm runtime. Crux is very similar, except both the app and (some of) the runtime is your responsibility. This means some more work, but it also means you only bring what you need and nothing more, both in terms of supported platforms and the necessary APIs.</p>
<p>In Crux, business logic written in Rust is captured in the update function mentioned above and the other pieces that the function needs: events, model and effects, each represented by a type. This code forms a Core, which is portable, and really easily testable.</p>
<p>The execution of effects, including drawing the user interface, is done in a native Shell. Its job is to draw the appropriate UI on screen, translate user interactions into events to send to the Core, and when requested, perform effects and return their outcomes back to the Core.</p>
<p><img src="guide/../crux.png" alt="The two sides of the Shell" /></p>
<p>The Shell thus has two sides: the <em>driving</em> side – the interactions causing events which push the Core to action, and the <em>driven</em> side, which services the Core's requests for side effects. Without being prompted by the Shell, the Core does nothing, it can't – with no other I/O, there are no other triggers which could cause the Core code to run. To the Shell, the Core is a simple library, providing some computation. From the perspective of the Core, the Shell is a platform the Core runs on.</p>
<h2 id="capabilities-the-syntax-sugar-for-effects"><a class="header" href="#capabilities-the-syntax-sugar-for-effects">Capabilities: the syntax sugar for effects</a></h2>
<p>Effects encode potentially quite complex, but common interactions, so they are the perfect candidate for some improved ergonomics in the APIs. This is where Crux capabilities come in. They provide a nicer API for creating effects, and in the future, they will likely provide implementations of the effect execution for the various supported platforms. Capabilities can also implement more complex interactions with the outside world, such as chained network API calls or processing results of effects, like parsing JSON API responses.</p>
<p>We will look at how capabilities work, and will build our own in the next chapter.</p>
<hr />
<div class="footnote-definition" id="testing"><sup class="footnote-definition-label">1</sup>
<p>In reality, we do need to check that at least one of our HTTP requests executes successfully, but once one does, it is very likely that so long as they are described correctly, all of them will.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h1>
<p>In the last chapter, we spoke about Effects. In this one we'll look at the APIs
your app will actually use to request them – the capabilities.</p>
<p>Capabilities are reusable, platform agnostic APIs for a particular type of
effect. They have two key jobs:</p>
<ol>
<li>Provide a nice ergonomic API for apps to use</li>
<li>Manage the communication between the app and the Shell</li>
</ol>
<p>From the perspective of the app, you can think of capabilities as an equivalent
to SDKs. And a lot of them will provide an interface to the actual platform
specific SDKs.</p>
<h2 id="intent-and-execution"><a class="header" href="#intent-and-execution">Intent and execution</a></h2>
<p>The Capabilities are the key to Crux being portable across as many platforms as
is sensible. Crux apps are, in a sense, built in the abstract, they describe
<em>what</em> should happen in response to events, but not <em>how</em> it should happen. We
think this is important both for portability, and for testing and general
separation of concerns. What should happen is inherent to the product, and
should behave the same way on any platform – it's part of what your app <em>is</em>.
How it should be executed (and exactly what it looks like) often depends on the
platform.</p>
<p>Different platforms may support different ways, for example a biometric
authentication may work very differently on various devices and some may not
even support it at all, but it may also be a matter of convention. Different
platforms may also have different practical restrictions: while it may be
perfectly appropriate to write things to disk on one platform, but internet
access can't be guaranteed (e.g. on a smart watch), on another, writing to disk
may not be possible, but internet connection is virtually guaranteed (e.g. in an
API service, or on an embedded device in a factory). A persistent caching
capability would implement the specific storage solution differently on
different platforms, but would potentially share the key format and eviction
strategy across them. The hard part of designing a capability is working out
exactly where to draw the line between what is the intent and what is the
implementation detail, what's common across platforms and what may be different
on each, and implementing the former in Rust in the capability and the latter on
the native side in the Shell, however is appropriate.</p>
<p>Because Capabilities can own the "language" used to express intent, and the
interface to request the execution of the effect, your Crux application code can
be portable onto any platform capable of executing the effect in some way.
Clearly, the number of different effects we can think of, and platforms we can
target is enormous, and Crux doesn't want to force you to implement the entire
portfolio of them on every platform. That's why Capabilities are delivered as
separate modules, typically in crates, and apps can declare which ones they
need. The Shell implementations need to know how to handle all requests from
those capabilities, but can choose to provide only stub implementations where
appropriate. For example the
<a href="https://github.com/redbadger/crux/tree/master/examples/cat_facts">Cat Facts example</a>,
uses a key-value store capability for persisting the model after every
interaction, which is crucial to make the CLI shell work statefully, but the
other shells generally ignore the key-value requests, because state persistence
across app launches is not crucial for them. The app itself (the Core) has no
idea which is the case.</p>
<p>In some cases, it may also make sense to implement an app-specific capability,
for effects specific to your domain, which don't have a common implementation
across platforms (e.g. registering a local user). Crux does not stop you from
bundling a number of capabilities alongside your apps (i.e. they don't <em>have to</em>
come from a crate). On the other hand, it might make sense to build a capability
on top of an existing lower-level capability, for example a CRDT capability may
use a general pub/sub capability as transport, or a specific protocol to speak
to your synchronization server (e.g. over HTTP).</p>
<p>There are clearly numerous scenarios, and the best rule of thumb we can think of
is "focus on the intent". Provide an API to describe the intent of side-effects
and then either pass the intent straight to the shell, or translate it to a
sequence of more concrete intents for the Shell to execute. And keep in mind
that the more complex the intent sent to the shell, the more complex the
implementation on each platform. The translation between high-level intent and
low level building blocks is why Capabilities exist.</p>
<h2 id="the-core-and-the-shell"><a class="header" href="#the-core-and-the-shell">The Core and the Shell</a></h2>
<p>As we've already covered, the capabilities effectively straddle the FFI boundary
between the Core and the Shell. On the Core side they mediate between the FFI
boundary and the application code. On the shell-side the requests produced by
the capability need to be actually executed and fulfilled. Each capability
therefore extends the Core/Shell interface with a set of defined (and type
checked) messages, in a way that allows Crux to leverage exhaustive pattern
matching on the native side to ensure all necessary capabilities required by the
Core are implemented.</p>
<p>At the moment the Shell implementation is up to you, but we think in the future
it's likely that capability crates will come with platform native code as well,
making building both the Core and the Shells easier, and allow you to focus on
application behaviour in the Core and look and feel in the Shell.</p>
<h2 id="using-capabilities"><a class="header" href="#using-capabilities">Using Capabilities</a></h2>
<p>Okay, time to get practical. We'll look at what it takes (and why) to use a
capability, and in the next couple of chapters, we'll continue to build one and
implement the Shell side of it.</p>
<p>Firstly, we need to have access to an instance of the capability in our <code>update</code>
function. Recall that the function signature is:</p>
<pre><code class="language-rust noplayground">fn update(&amp;self, msg: Self::Event, model: &amp;mut Self::Model, caps: &amp;Self::Capabilities)</code></pre>
<p>We get the capabilities in the <code>caps</code> argument. You may be wondering why that's
necessary. At first glance, we could be able to just create a capability
instance ourselves, or not need one at all, after all they just provide API to
make effects. There are a few reasons.</p>
<p>Firstly, capabilities need to be able to send a message to the shell, more
precisely, they need to be able to add to the set of effects which result from
the run of the update function. Sounds like a return value to you? It kind of
is, and we tried that, and the type signatures involved quickly become quite
unsightly. It's not the only reason though. They also need to be able to return
information back to your app by queuing up events to be dispatched to the next
run of the <code>update</code> function. But to be <em>really</em> useful, they need to be able to
do a series of these things and suspend their execution in the meantime.</p>
<p>In order to enable all that, Crux needs to be in charge of creating the instance
of the capabilities to provide context to them, which they use to do the things
we just listed. We'll see the details of this in the next chapter.</p>
<p>Notice that the type of the argument is <code>Self::Capabilities</code> — you own the type.
This is to allow you to declare which capabilities you want to use in your app.
That type will most likely be a struct looking like the following:</p>
<pre><code class="language-rust noplayground">#[derive(Effect)]
pub struct Capabilities {
    pub http: Http&lt;Event&gt;,
    pub render: Render&lt;Event&gt;,
}</code></pre>
<p>Those two types come from <code>crux_core</code> and <code>crux_http</code>. Two things are suspicious
about the above — the <code>Event</code> type, which describes your app's events and the
<code>#[derive(Effect)]</code> derive macro.</p>
<p>The latter generates an <code>Effect</code> enum for you, used as the payload of the
messages to the Shell. It is one of the things you will need to expose via the
FFI boundary. It's the type the Shell will use to understand what is being
requested from it, and it mirrors the <code>Capabilities</code> struct: for each field,
there is a tuple variant in the Effect enum, with the respective capability's
<em>request</em> as payload, i.e. the data describing what's being asked of the Shell.</p>
<p>The <code>Event</code> type argument enables the "shell side" of these capabilities to send
you your specific events back as the <em>outcome</em> of their work. Typically, you'd
probably set up an <code>Event</code> variant specifically for the individual uses of each
capability, like this:</p>
<pre><code class="language-rust noplayground">#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
pub enum Event {
    Hello,
    #[serde(skip)]
    Set(crux_http::Result&lt;crux_http::Response&lt;Counter&gt;&gt;), // &lt;- this
}</code></pre>
<p>In a real app, you'd likely have more than one interaction with a HTTP server,
and would most likely need one variant for each. (<code>#[serde(skip)]</code> in the above
code hides the variant from the type exposed to the Shell for direct calls –
this event should not be dispatched directly. The other reason for it also has
to do with serialization difficulties, which we'll eventually iron out).</p>
<p>That's it for linking the capability into our app, now we can use it in the
<code>update</code> function:</p>
<pre><code class="language-rust noplayground">    fn update(&amp;self, msg: Self::Event, model: &amp;mut Self::Model, caps: &amp;Self::Capabilities) {
        match msg {
            Event::Get =&gt; {
                caps.http
                    .get(API_URL)
                    .expect_json::&lt;Counter&gt;()
                    .send(Event::Set);

                caps.render.render();
            }
    // ...</code></pre>
<p>You can see the use of the <code>Event::Set</code> variant we just discussed. <code>Event::Set</code>
is technically a function with this signature:</p>
<pre><code class="language-rust noplayground">fn Event::Set(crux_http::Result&lt;crux_http::Response&lt;Counter&gt;) -&gt; Event</code></pre>
<p>Looks a lot like a callback, doesn't it. Yep. With the difference that the
result is an <code>Event</code>. Generally, you should be able to completely ignore this
detail and just use your variant names and the code should read pretty clearly:
"When done, send me <code>Event::Set</code>".</p>
<p>The other nuance to be aware of is that the capability calls return immediately.
This should hopefully be relatively obvious by now, but all that's happening is
effects are getting queued up to be requested from the Shell. In a way,
capability calls are implicitly asynchronous (but you can't await them).</p>
<p>That's generally all there is to it. What you'll notice is that most
capabilities have essentially request/response semantics — you use their APIs,
and provide an event you want back, and eventually your update function will get
called with that event. Most capabilities take inputs for their effect, and
return output in their outcomes, but some capabilities don't do one or either of
those things. Render is an example of a capability which doesn't take payload
and never calls back. You'll likely see all the different variations in Crux
apps.</p>
<h2 id="orchestrating-capability-calls"><a class="header" href="#orchestrating-capability-calls">Orchestrating capability calls</a></h2>
<p>In more complex apps, you might run into situations where you need to run
several effects in parallel, race them, run them in sequence or a combination of
the above. In other words, in some scenarios, you really need the full control
of <code>async</code>/<code>await</code> and the futures APIs.</p>
<p>To support this case, Crux provides a built-in capability called <code>Compose</code>,
which provides restricted but direct access to the capability runtime (more
about the runtime in the next chapter), which supports <code>async</code>. To use it, first
add it to your Capabilities struct:</p>
<pre><code class="language-rust noplayground">use crux::compose::Compose;

#[derive(crux_core::macros::Effect)]
pub struct Capabilities {
    pub http: Http&lt;Event&gt;,
    pub render: Render&lt;Event&gt;,
    #[effect(skip)] // skips the compose variant when deriving an Effect enum
    pub compose: Compose&lt;Event&gt;,
}</code></pre>
<p>Then, you can use it in your update function like this:</p>
<pre><code class="language-rust noplayground">fn update(&amp;self, msg: Event, model: &amp;mut Model, caps: &amp;Capabilities) {
    match msg {
        Event::GetDocuments =&gt; caps.compose.spawn(|context| {
            let http = caps.http.clone();

            async move {
                let ids = http
                    .get(DOCS_URL)
                    .await
                    .expect("Request should send")
                    .body_json::&lt;Vec&lt;Id&gt;&gt;()
                    .await
                    .expect("Ids failed to parse as JSON");

                let futs: Vec&lt;_&gt; = ids
                    .iter()
                    .map(|id| {
                        let http = http.clone();

                        async move {
                            http.get(&amp;format!("{}/{}", DOCS_URL, id))
                                .await
                                .expect("request did not send")
                                .body_json::&lt;Doc&gt;()
                                .await
                                .expect("doc failed to parse as JSON")
                        }
                    })
                    .collect();

                let docs = futures::future::join_all(futs).await;

                context.update_app(Event::FetchedDocuments(docs))
            }
        }),
        // ...
    }
}</code></pre>
<p>The above code first fetches a list of document IDs, then fetches each document
in parallel, and finally returns the list of documents as an event.</p>
<p>The <code>spawn</code> method takes a closure which is passed a <code>ComposeContext</code> argument.
This is a handle to the capability runtime, which allows you to send events back
to the app. The closure must return a future, which is then spawned on the
runtime. The runtime will drive the future to completion. You can call
<code>context.update_app</code> multiple times if necessary.</p>
<p>One consideration of this style of orchestration is that the more effects you
string together this way, the harder it will be to test the behaviour of this
ad-hoc capability, because you can't start the transaction in the middle.
Generally, if you find yourself sending events using <code>update_app</code> and then
continuing to emit more effects, you should probably break the orchestration up
into smaller blocks executed in response to the events in the update function
instead.</p>
<p>Now that we know how to use capabilities, we're ready to look at building our
own ones. You may never need to do that, or it might be one of the first hurdles
you'll come across (and if we're honest, given how young Crux is, it's more
likely the latter). Either way, it's what we'll do in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capability-apis"><a class="header" href="#capability-apis">Capability APIs</a></h1>
<p>In the previous chapter, we looked at the purpose of Capabilities and using them
in Crux apps. In this one, we'll go through building our own. It will be a
simple one, but real enough to show the key parts.</p>
<p>We'll extend the Counter example we've built in the
<a href="guide/hello_world.html">Hello World</a> chapter and make it <em>worse</em>. Intentionally. We'll
add a random delay before we actually update the counter, just to annoy the user
(please don't do that in your real apps). It is a silly example, but it will
allow us to demonstrate a few things:</p>
<ul>
<li>Random numbers, current time and delay are also side-effects</li>
<li>To introduce a random delay, we will need to chain two effects behind a single
capability call</li>
<li>The capability can also offer specific time delay API and we can show how
capabilities with multiple <em>operations</em> work.</li>
</ul>
<p>In fact, let's start with that.</p>
<h2 id="basic-delay-capability"><a class="header" href="#basic-delay-capability">Basic delay capability</a></h2>
<p>The first job of our capability will be to pause for a given number of
milliseconds and then send an event to the app.</p>
<p>There's a number of types and traits we will need to implement to make the
capability work with the rest of Crux, so let's quickly go over them before we
start. We will need</p>
<ul>
<li>The capability itself, able to hold on to the context used to interact with
Crux</li>
<li>The payload type for the effect, holding the number of milliseconds requested</li>
<li>Implementation of the <code>Capability</code> trait</li>
</ul>
<p>Let's start with the payload:</p>
<pre><code class="language-rust noplayground">#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub struct DelayOperation {
    millis: usize
}</code></pre>
<p>The request is just a named type holding onto a number. It will need to cross
the FFI boundary, which is why it needs to be serializable, cloneable, etc.</p>
<p>We will need our request to implement the <code>Operation</code> trait, which links it with
the type of the response we expect back. In our case we expect a response, but
there is no data, so we'll use the unit type.</p>
<pre><code class="language-rust noplayground">use crux_core::capability::Operation;

impl Operation for DelayOperation {
    type Output = ();
}</code></pre>
<p>Now we can implement the capability:</p>
<pre><code class="language-rust noplayground">use crux_core::capability::CapabilityContext;
use crux_core::macros::Capability;

#[derive(Capability)]
struct Delay&lt;Ev&gt; {
    context: CapabilityContext&lt;DelayOperation, Ev&gt;,
}

impl&lt;Ev&gt; Delay&lt;Ev&gt;
where
    Ev: 'static,
{
    pub fn new(context: CapabilityContext&lt;DelayOperation, Ev&gt;) -&gt; Self {
        Self { context }
    }

    pub fn milliseconds(&amp;self, millis: usize, event: Ev)
    where
        Ev: Send,
    {
        let ctx = self.context.clone();
        self.context.spawn(async move {
            ctx.request_from_shell(DelayOperation { millis }).await;

            ctx.update_app(event);
        });
    }
}</code></pre>
<p>There's a fair bit going on. The capability is generic over an event type <code>Ev</code>
and holds on to a <code>CapabilityContext</code>. The constructor will be called by Crux
when starting an application that uses this capability.</p>
<p>The <code>milliseconds</code> method is our capability's public API. It takes the delay in
milliseconds and the event to send back. In this case, we don't expect any
payload to return, so we take the <code>Ev</code> type directly. We'll shortly see what an
event with data looks like as well.</p>
<p>The implementation of the method has a little bit of boilerplate to enable us to
use <code>async</code> code. First we clone the context to be able to use it in the async
block. Then we use the context to spawn an <code>async move</code> code block in which
we'll be able to use <code>async</code>/<code>await</code>. This bit of code will be the same in every
part of your capability that needs to interact with the Shell.</p>
<p>You can see we use two APIs to orchestrate the interaction. First
<code>request_from_shell</code> sends the delay operation we made earlier to the Shell.
This call returns a future, which we can <code>.await</code>. Once done, we use the other
API <code>update_app</code> to dispatch the event we were given. At the <code>.await</code>, the task
will be suspended, Crux will pass the operation to the Shell wrapped in the
<code>Effect</code> type we talked about in the last chapter and the Shell will use its
native APIs to wait for the given duration, and eventually respond. This will
wake our task up again and we can continue working.</p>
<p>Finally, we need to implement the <code>Capability</code> trait. This is done for us by the
<code>#[derive(Capability)]</code> macro, but it is worth looking at the generated code:</p>
<pre><code class="language-rust noplayground">impl&lt;Ev&gt; Capability&lt;Ev&gt; for Delay&lt;Ev&gt; {
    type Operation = DelayOperation;
    type MappedSelf&lt;MappedEv&gt; = Delay&lt;MappedEv&gt;;

    fn map_event&lt;F, NewEv&gt;(&amp;self, f: F) -&gt; Self::MappedSelf&lt;NewEv&gt;
    where
        F: Fn(NewEv) -&gt; Ev + Send + Sync + Copy + 'static,
        Ev: 'static,
        NewEv: 'static,
    {
        Delay::new(self.context.map_event(f))
    }
}</code></pre>
<p>What on earth is that for, you ask? This allows you to derive an instance of the
<code>Delay</code> capability from an existing one and adapt it to a different <code>Event</code>
type. Yes, we know, don't read that sentence again. This will be useful to allow
composing Crux apps from smaller Crux apps to automatically wrap the child
events in the parent events.</p>
<p>We will cover this in depth in the chapter about
<a href="guide/./composing.html">Composable applications</a>.</p>
<h2 id="random-delays"><a class="header" href="#random-delays">Random delays</a></h2>
<p>To make the example more contrived, but also more educational, we'll add the
random delay ability. This will</p>
<ul>
<li>Request a random number within given limits from the shell</li>
<li>Then request the shell to delay by that number</li>
<li>Then update the application, passing the number along, in case it is needed</li>
</ul>
<p>First off, we need to add the new operation in. Here we have a choice, we can
add a random delay operation, or we can add a random number generation operation
and compose the two building blocks ourselves. We'll go for the second option
because... well because this is an example.</p>
<p>Since we have multiple operations now, let's make our operation an enum</p>
<pre><code class="language-rust noplayground">#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub enum DelayOperation {
    GetRandom(usize, usize),
    Delay(usize),
}</code></pre>
<p>We now also need an output type:</p>
<pre><code class="language-rust noplayground">#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub enum DelayOutput {
    Random(usize),
    TimeUp
}</code></pre>
<p>And that changes the <code>Operation</code> trait implementation:</p>
<pre><code class="language-rust noplayground">impl Operation for DelayOperation {
    type Output = DelayOutput;
}</code></pre>
<p>The updated implementation looks like the following:</p>
<pre><code class="language-rust noplayground">impl&lt;Ev&gt; Delay&lt;Ev&gt;
where
    Ev: 'static,
{
    pub fn new(context: CapabilityContext&lt;DelayOperation, Ev&gt;) -&gt; Self {
        Self { context }
    }

    pub fn milliseconds(&amp;self, millis: usize, event: Ev) {
        let ctx = self.context.clone();
        self.context.spawn(async move {
            ctx.request_from_shell(DelayOperation::Delay(millis)).await; // Changed

            ctx.update_app(event);
        });
    }

    pub fn random&lt;F&gt;(&amp;self, min: usize, max: usize, event: F)
    where F: Fn(usize) -&gt; Ev
    {
        let ctx = self.context.clone();
        self.context.spawn(async move {
            let response = ctx.request_from_shell(DelayOperation::GetRandom(min, max)).await;

            let DelayOutput::Random(millis) = response else {
                panic!("Expected a random number")
            };
            ctx.request_from_shell(DelayOperation::Delay(millis)).await;

            ctx.update_app(event(millis));
        });
    }
}</code></pre>
<p>In the new API, the event handling is a little different from the original.
Because the event has a payload, we don't simply take an <code>Ev</code>, we need a
function that returns <code>Ev</code>, if given the random number. Seems cumbersome but
you'll see using it in the <code>update</code> function of our app is quite natural:</p>
<pre><code class="language-rust noplayground">fn update(&amp;self, event: Self::Event, model: &amp;mut Self::Model, caps: &amp;Self::Capabilities) {
    match event {
        //
        // ... Some events omitted
        //
        Event::Increment =&gt; {
            caps.delay.random(200, 800, Event::DoIncrement);
        }
        Event::DoIncrement(_millis) =&gt; {
            // optimistic update
            model.count.value += 1;
            model.confirmed = Some(false);
            caps.render.render();

            // real update
            let base = Url::parse(API_URL).unwrap();
            let url = base.join("/inc").unwrap();
            caps.http.post(url.as_str()).expect_json().send(Event::Set);
        }
        Event::Decrement =&gt; {
            caps.delay.milliseconds(500, Event::DoIncrement);
        }
        Event::DoDecrement =&gt; {
            // optimistic update
            model.count.value -= 1;
            model.confirmed = Some(false);
            caps.render.render();

            // real update
            let base = Url::parse(API_URL).unwrap();
            let url = base.join("/dec").unwrap();
            caps.http.post(url.as_str()).expect_json().send(Event::Set);
        }
    }
}</code></pre>
<p>That is essentially it for the capabilities. You can check out the complete
context API
<a href="https://docs.rs/crux_core/latest/crux_core/capability/struct.CapabilityContext.html">in the docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-guide-to-testing-crux-apps"><a class="header" href="#a-guide-to-testing-crux-apps">A guide to testing Crux apps</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>One of the most compelling consequences of the Crux architecture is that it
becomes trivial to comprehensively test your application. This is because the
core is pure and therefore completely deterministic — all the side effects are
pushed to the shell.</p>
<p>It's straightforward to write an exhaustive set of unit tests that give you
complete confidence in the correctness of your application code — you can test
the behavior of your application independently of platform-specific UI and API
calls.</p>
<p>There is no need to mock/stub anything, and there is no need to write
integration tests.</p>
<p>Not only are the unit tests easy to write, but they run extremely quickly, and
can be run in parallel.</p>
<p>For example, the
<a href="https://github.com/redbadger/crux/tree/master/examples/notes">Notes example app</a>
contains complex logic related to collaborative text-editing using Conflict-free
Replicated Data Types (CRDTs). The test suite consists of 25 tests that give us
high coverage and high confidence of correctness. Many of the tests include
instantiating two instances (alice and bob) and checking that, even during
complex edits, the synchronization between them works correctly.</p>
<p>This test, for example, ensures that when Alice and Bob both insert text at the
same time, they both end up with the same result. It runs in 4 milliseconds.</p>
<pre><code class="language-rust ignore no_run">#[test]
fn two_way_sync() {
    let (mut alice, mut bob) = make_alice_and_bob();

    alice.update(Event::Insert("world".to_string()));
    let edits = alice.edits.drain(0..).collect::&lt;Vec&lt;_&gt;&gt;();

    bob.send_edits(edits.as_ref());

    // Alice's inserts should go in front of Bob's cursor
    // so we break the ambiguity of same cursor position
    // as quickly as possible
    bob.update(Event::Insert("Hello ".to_string()));
    let edits = bob.edits.drain(0..).collect::&lt;Vec&lt;_&gt;&gt;();

    alice.send_edits(edits.as_ref());

    let alice_view = alice.view();
    let bob_view = bob.view();

    assert_eq!(alice_view.text, "Hello world".to_string());
    assert_eq!(alice_view.text, bob_view.text);
}</code></pre>
<p>And the full suite of 25 tests runs in 16 milliseconds.</p>
<pre><code class="language-txt">cargo nextest run --release -p shared
    Finished release [optimized] target(s) in 0.07s
    Starting 25 tests across 2 binaries
        PASS [   0.005s] shared app::editing_tests::handles_emoji
        PASS [   0.005s] shared app::editing_tests::removes_character_before_cursor
        PASS [   0.005s] shared app::editing_tests::moves_cursor
        PASS [   0.006s] shared app::editing_tests::inserts_text_at_cursor_and_renders
        PASS [   0.005s] shared app::editing_tests::removes_selection_on_backspace
        PASS [   0.005s] shared app::editing_tests::removes_character_after_cursor
        PASS [   0.005s] shared app::editing_tests::removes_selection_on_delete
        PASS [   0.007s] shared app::editing_tests::changes_selection
        PASS [   0.006s] shared app::editing_tests::renders_text_and_cursor
        PASS [   0.006s] shared app::editing_tests::replaces_empty_range_and_renders
        PASS [   0.005s] shared app::editing_tests::replaces_range_and_renders
        PASS [   0.005s] shared app::note::test::splices_text
        PASS [   0.005s] shared app::editing_tests::replaces_selection_and_renders
        PASS [   0.004s] shared app::save_load_tests::opens_a_document
        PASS [   0.005s] shared app::note::test::inserts_text
        PASS [   0.005s] shared app::save_load_tests::saves_document_when_typing_stops
        PASS [   0.005s] shared app::save_load_tests::starts_a_timer_after_an_edit
        PASS [   0.006s] shared app::save_load_tests::creates_a_document_if_it_cant_open_one
        PASS [   0.005s] shared app::sync_tests::concurrent_clean_edits
        PASS [   0.005s] shared app::sync_tests::concurrent_conflicting_edits
        PASS [   0.005s] shared app::sync_tests::one_way_sync
        PASS [   0.005s] shared app::sync_tests::remote_delete_moves_cursor
        PASS [   0.005s] shared app::sync_tests::remote_insert_behind_cursor
        PASS [   0.004s] shared app::sync_tests::two_way_sync
        PASS [   0.005s] shared app::sync_tests::receiving_own_edits
------------
     Summary [   0.016s] 25 tests run: 25 passed, 0 skipped
</code></pre>
<h2 id="writing-a-simple-test"><a class="header" href="#writing-a-simple-test">Writing a simple test</a></h2>
<p>Crux provides a simple test harness that we can use to write unit tests for our
application code. Strictly speaking it's not needed, but it makes it easier to
avoid boilerplate and to write tests that are easy to read and understand.</p>
<p>Let's take a
<a href="https://github.com/redbadger/crux/blob/master/examples/notes/shared/src/app.rs#L379">really simple test</a>
from the
<a href="https://github.com/redbadger/crux/tree/master/examples/notes">Notes example app</a>
and walk through it step by step — the test replaces some selected text in a
document and checks that the correct text is rendered.</p>
<p>The first thing to do is create an instance of the <code>AppTester</code> test harness,
which runs our app (<code>NoteEditor</code>) and makes it easy to analyze the <code>Event</code>s and
<code>Effect</code>s that are generated.</p>
<pre><code class="language-rust ignore no_run">let app = AppTester::&lt;NoteEditor, _&gt;::default();</code></pre>
<p>The <code>Model</code> is normally private to the app (<code>NoteEditor</code>), but <code>AppTester</code>
allows us to set it up for our test. In this case the document contains the
string <code>"hello"</code> with the last two characters selected.</p>
<pre><code class="language-rust ignore no_run">let mut model = Model {
    note: Note::with_text("hello"),
    cursor: TextCursor::Selection(3..5),
    ..Default::default()
};</code></pre>
<p>Let's insert some text under the selection range. We simply create an <code>Event</code>
that captures the user's action and pass it into the app's <code>update()</code> method,
along with the Model we just created (which we will be able to inspect
afterwards).</p>
<pre><code class="language-rust ignore no_run">let event = Event::Insert("ter skelter".to_string());
let update = app.update(event, &amp;mut model);</code></pre>
<p>We can check that the shell was asked to render by using the
<a href="https://docs.rs/crux_core/latest/crux_core/macro.assert_effect.html"><code>assert_effect!</code></a>
macro, which panics if none of the effects generated by the update matches the
specified pattern.</p>
<pre><code class="language-rust ignore no_run">assert_effect!(update, Effect::Render(_));</code></pre>
<p>Finally we can ask the app for its <code>ViewModel</code> and use it to check that the text
was inserted correctly and that the cursor position was updated.</p>
<pre><code class="language-rust ignore no_run">let view = app.view(&amp;model);

assert_eq!(view.text, "helter skelter".to_string());
assert_eq!(view.cursor, TextCursor::Position(14));</code></pre>
<h2 id="writing-a-more-complicated-test"><a class="header" href="#writing-a-more-complicated-test">Writing a more complicated test</a></h2>
<p>Now let's take a
<a href="https://github.com/redbadger/crux/blob/master/examples/notes/shared/src/app.rs#L630">more complicated test</a>
and walk through that. This test checks that a "save" timer is restarted each
time the user edits the document (after a second of no activity the document is
stored). Note that the <em>actual</em> timer is run by the shell (because it is a side
effect, which would make it really tricky to test) — but all we need to do is
check that the behavior of the timer is correct (i.e. started, finished and
cancelled correctly).</p>
<p>Again, the first thing we need to do is create an instance of the <code>AppTester</code>
test harness, which runs our app (<code>NoteEditor</code>) and makes it easy to analyze the
<code>Event</code>s and <code>Effect</code>s that are generated.</p>
<pre><code class="language-rust ignore no_run">let app = AppTester::&lt;NoteEditor, _&gt;::default();</code></pre>
<p>We again need to set up a <code>Model</code> that we can pass to the <code>update()</code> method.</p>
<pre><code class="language-rust ignore no_run">let mut model = Model {
    note: Note::with_text("hello"),
    cursor: TextCursor::Selection(2..4),
    ..Default::default()
};</code></pre>
<p>We send an <code>Event</code> (e.g. raised in response to a user action) into our app in
order to check that it does the right thing.</p>
<p>Here we send an Insert event, which should start a timer. We filter out just the
<code>Effect</code>s that were created by the <code>Timer</code> Capability, mapping them to their
inner <code>Request&lt;TimerOperation&gt;</code> type.</p>
<pre><code class="language-rust ignore no_run">let requests = &amp;mut app
    .update(Event::Insert("something".to_string()), &amp;mut model)
    .into_effects()
    .filter_map(Effect::into_timer);</code></pre>
<p>There are a few things to discuss here. Firstly, the <code>update()</code> method returns
an <code>Update</code> struct, which contains vectors of <code>Event</code>s and <code>Effect</code>s. We are
only interested in the <code>Effect</code>s, so we call <code>into_effects()</code> to consume them as
an <code>Iterator</code> (there are also <code>effects()</code> and <code>effects_mut()</code> methods that allow
us to borrow the <code>Effect</code>s instead of consuming them, but we don't need that
here). Secondly, we use the <code>filter_map()</code> method to filter out just the
<code>Effect</code>s that were created by the <code>Timer</code> Capability, using
<code>Effect::into_timer</code> to map the <code>Effect</code>s to their inner
<code>Request&lt;TimerOperation&gt;</code>.</p>
<p>The <a href="https://github.com/redbadger/crux/tree/master/crux_macros"><code>Effect</code></a> derive
macro generates filters and maps for each capability that we are using. So if
our <code>Capabilities</code> struct looked like this...</p>
<pre><code class="language-rust ignore no_run">
#[cfg_attr(feature = "typegen", derive(crux_core::macros::Export))]
#[derive(Effect)]
pub struct Capabilities {
    timer: Timer&lt;Event&gt;,
    render: Render&lt;Event&gt;,
    pub_sub: PubSub&lt;Event&gt;,
    key_value: KeyValue&lt;Event&gt;,
}</code></pre>
<p>... we would get the following filters and filter_maps:</p>
<pre><code class="language-rust ignore no_run">// filters
Effect::is_timer(&amp;self) -&gt; bool
Effect::is_render(&amp;self) -&gt; bool
Effect::is_pub_sub(&amp;self) -&gt; bool
Effect::is_key_value(&amp;self) -&gt; bool
// filter_maps
Effect::into_timer(self) -&gt; Option&lt;Request&lt;TimerOperation&gt;&gt;
Effect::into_render(self) -&gt; Option&lt;Request&lt;RenderOperation&gt;&gt;
Effect::into_pub_sub(self) -&gt; Option&lt;Request&lt;PubSubOperation&gt;&gt;
Effect::into_key_value(self) -&gt; Option&lt;Request&lt;KeyValueOperation&gt;&gt;</code></pre>
<p>We want to check that the first request is a <code>Start</code> operation, and that the
timer is set to fire in 1000 milliseconds. The macro
<a href="https://docs.rs/assert_let_bind/0.1.1/assert_let_bind/"><code>assert_let!()</code></a> does a
pattern match for us and assigns the <code>id</code> to a local variable called <code>first_id</code>,
which we'll use later. Finally, we don't expect any more timer requests to have
been generated.</p>
<pre><code class="language-rust ignore no_run">// this is mutable so we can resolve it later
let request = &amp;mut requests.next().unwrap();
assert_let!(
    TimerOperation::Start {
        id: first_id,
        millis: 1000
    },
    request.operation.clone()
);
assert!(requests.next().is_none());</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/testing.html#admonition-note"></a>
</div>
<div>
<p>There are other ways to analyze effects from the update.</p>
<p>You can take all the effects that match a predicate out of the update:</p>
<pre><code class="language-rust ignore no_run">let requests = update.take_effects(|effect| effect.is_timer());
// or
let requests = update.take_effects(Effect::is_timer);</code></pre>
<p>Or you can partition the effects into those that match the predicate and those
that don't:</p>
<pre><code class="language-rust ignore no_run">// split the effects into HTTP requests and renders
let (timer_requests, other_requests) = update.take_effects_partitioned_by(Effect::is_timer);</code></pre>
<p>There are also <code>expect_*</code> methods that allow you to assert and return a certain
type of effect:</p>
<pre><code class="language-rust ignore no_run">// this is mutable so we can resolve it later
let request = &amp;mut timer_requests.pop_front().unwrap().expect_timer();
assert_eq!(
    request.operation,
    TimerOperation::Start { id: 1, millis: 1000 }
);
assert!(timer_requests.is_empty());</code></pre>
</div>
</div>
<p>At this point the shell would start the timer (this is something the core can't
do as it is a side effect) and so we need to tell the app that it was created.
We do this by "resolving" the request.</p>
<p>Remember that <code>Request</code>s either resolve zero times (fire-and-forget, e.g. for
<code>Render</code>), once (request/response, e.g. for <code>Http</code>), or many times (for streams,
e.g. <code>Sse</code> — Server-Sent Events). The <code>Timer</code> capability falls into the
"request/response" category, so we need to resolve the <code>Start</code> request with a
<code>Created</code> response. This tells the app that the timer has been started, and
allows it to cancel the timer if necessary.</p>
<p>Note that resolving a request could call the app's <code>update()</code> method resulting
in more <code>Event</code>s being generated, which we need to feed back into the app.</p>
<pre><code class="language-rust ignore no_run">let update = app.resolve(request, TimerOutput::Created { id: first_id }).unwrap();
for event in update.events {
    let _ = app.update(event, &amp;mut model);
}

// or, if this event "settles" the app
let _updated = app.resolve_to_event_then_update(
    request,
    TimerOutput::Created { id: first_id },
    &amp;mut model
);</code></pre>
<p>Before the timer fires, we'll insert another character, which should cancel the
existing timer and start a new one.</p>
<pre><code class="language-rust ignore no_run">let mut requests = app
    .update(Event::Replace(1, 2, "a".to_string()), &amp;mut model)
    .into_effects()
    .filter_map(Effect::into_timer);

let cancel_request = requests.next().unwrap();
assert_let!(
    TimerOperation::Cancel { id: cancel_id },
    cancel_request.operation
);
assert_eq!(cancel_id, first_id);

let start_request = &amp;mut requests.next().unwrap(); // this is mutable so we can resolve it later
assert_let!(
    TimerOperation::Start {
        id: second_id,
        millis: 1000
    },
    start_request.operation.clone()
);
assert_ne!(first_id, second_id);

assert!(requests.next().is_none());</code></pre>
<p>Now we need to tell the app that the second timer was created.</p>
<pre><code class="language-rust ignore no_run">let update = app
    .resolve(start_request, TimerOutput::Created { id: second_id })
    .unwrap();
for event in update.events {
    app.update(event, &amp;mut model);
}</code></pre>
<p>In the real world, time passes and the timer fires, but all we have to do is to
resolve our start request again, but this time with a <code>Finished</code> response.</p>
<pre><code class="language-rust ignore no_run">let update = app
    .resolve(start_request, TimerOutput::Finished { id: second_id })
    .unwrap();
for event in update.events {
    app.update(event, &amp;mut model);
}</code></pre>
<p>Another edit should result in another timer, but not in a cancellation:</p>
<pre><code class="language-rust ignore no_run">let update = app.update(Event::Backspace, &amp;mut model);
let mut requests = update.into_effects().filter_map(Effect::into_timer);

assert_let!(
    TimerOperation::Start {
        id: third_id,
        millis: 1000
    },
    requests.next().unwrap().operation
);
assert!(requests.next().is_none()); // no cancellation

assert_ne!(third_id, second_id);</code></pre>
<p>Note that this test was not about testing whether the model was updated
correctly (that is covered in other tests) so we don't call the app's <code>view()</code>
method — it's just about checking that the timer is started, cancelled and
restarted correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-interface-between-core-and-shell"><a class="header" href="#message-interface-between-core-and-shell">Message interface between core and shell</a></h1>
<p>So far in this book, we've been taking the perspective of being inside the core
looking out. It feels like it's now time to be in the shell, looking in.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="guide/message_interface.html#admonition-note"></a>
</div>
<div>
<p>Interestingly, we think this is also the way to approach building apps with Crux. For any one feature, start in the middle and get your behaviour established first. Write the tests without the UI and the other side-effects in the way. Give yourself maximum confidence that the feature works <em>exactly</em> as you expect before you muddy the water with UI components, and their look and feel.</p>
</div>
</div>
<p>OK, let's talk about the shell.</p>
<p>The shell only has two responsibilities:</p>
<ol>
<li>Laying out the UI components</li>
<li>Supporting the app's capabilities</li>
</ol>
<p>We'll look at these separately. But first let's remind ourselves of how we
interact with the core (now would be a good time to read
<a href="guide/../getting_started/core.html">Shared core and types</a> if you haven't already).</p>
<h2 id="the-message-protocol"><a class="header" href="#the-message-protocol">The message protocol</a></h2>
<p>The interface is message based, and uses serialization to pass data back and
forth. The core exports the types for all the data so that it can be used and
created on the shell side with safety.</p>
<p>An <code>Event</code> can be passed in directly, as-is. Processing of <code>Effect</code>s is a little
more complicated, because the core needs to be able to pair the outcomes of the
effects with the original capability call, so it can return them to the right
caller. To do that, effects are wrapped in a <code>Request</code>, which tags them with an
Id. To respond, the same Id needs to be passed back in.</p>
<p>Requests from the core are emitted serialized, and need to be deserialized
first. Both events and effect outputs need to be serialized before being passed
back to the core.</p>
<div id="admonition-sharp-edge" class="admonition admonish-warning" role="note" aria-labelledby="admonition-sharp-edge-title">
<div class="admonition-title">
<div id="admonition-sharp-edge-title">
<p>Sharp edge</p>
</div>
<a class="admonition-anchor-link" href="guide/message_interface.html#admonition-sharp-edge"></a>
</div>
<div>
<p>It is likely that this will become an implementation detail and instead, Crux will provide a more ergonomic shell-side API for the interaction, hiding both the EffectId pairing and the serialization (and allowing us to iterate on the FFI implementation which, we think, could work better).</p>
</div>
</div>
<h2 id="the-core-interface"><a class="header" href="#the-core-interface">The core interface</a></h2>
<p>There are only three touch-points with the core.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn process_event(data: &amp;[u8]) -&gt; Vec&lt;u8&gt; { todo!() }
pub fn handle_response(id: u32, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; { todo!() }
pub fn view() -&gt; Vec&lt;u8&gt; { todo!() }
<span class="boring">}</span></code></pre></pre>
<p>The <code>process_event</code> function takes a serialized <code>Event</code> (from a UI interaction)
and returns a serialized vector of <code>Request</code>s that the shell can dispatch to the
relevant capability's shell-side code (see the section below on how the shell
handles capabilities).</p>
<p>The <code>handle_response</code> function, used to return capability output back into the
core, is similar to <code>process_event</code> except that it also takes a <code>id</code>, which
ties the output (for example a HTTP response) being submitted with it's original
<code>Effect</code> which started it (and the corresponding request which the core wrapped
it in).</p>
<p>The <code>view</code> function simply retrieves the serialized view model (to which the UI
is bound) and is called by the shell after it receives a <code>Render</code> request. The
view model is a projection of the app's state – it reflects what information the
Core wants displayed on screen.</p>
<p>You're probably thinking, "Whoa! I just see slices and vectors of bytes, where's
the type safety?". Well, the answer is that we also generate all the types that
pass through the bridge, for each language, along with serialization and
deserialization helpers. This is done by the <code>serde-generate</code> crate (see the
section on
<a href="guide/../getting_started/core.html#create-the-shared-types-crate">Create the shared types crate</a>).</p>
<div id="admonition-sharp-edge-1" class="admonition admonish-warning" role="note" aria-labelledby="admonition-sharp-edge-1-title">
<div class="admonition-title">
<div id="admonition-sharp-edge-1-title">
<p>Sharp edge</p>
</div>
<a class="admonition-anchor-link" href="guide/message_interface.html#admonition-sharp-edge-1"></a>
</div>
<div>
<p>For now we have to manually invoke the serialization code in the shell. At some point this may be abstracted away.</p>
</div>
</div>
<p>In this code snippet from the
<a href="https://github.com/redbadger/crux/blob/master/examples/counter/Android/app/src/main/java/com/example/counter/Core.kt">Counter example</a>,
notice that we call <code>processEvent</code> and <code>handleResponse</code> on the core depending on
whether we received an <code>Event</code> from the UI or from a capability, respectively.
Regardless of which core function we call, we get back a bunch of requests,
which we can iterate through and do the relevant thing (the following snippet
triggers a render of the UI, or makes an HTTP call, or launches a task to wait
for Server Sent Events, depending on what the core requested):</p>
<pre><code class="language-kotlin">class Core : androidx.lifecycle.ViewModel() {
    var view: ViewModel? by mutableStateOf(null)
        private set

    private val httpClient = HttpClient(CIO)
    private val sseClient = HttpClient(CIO) {
        engine {
            endpoint {
                keepAliveTime = 5000
                connectTimeout = 5000
                connectAttempts = 5
                requestTimeout = 0
            }
        }
    }

    init {
        viewModelScope.launch {
            update(Event.StartWatch())
        }
    }

    suspend fun update(event: Event) {
        val effects = processEvent(event.bincodeSerialize())

        val requests = Requests.bincodeDeserialize(effects)
        for (request in requests) {
            processEffect(request)
        }
    }

    private suspend fun processEffect(request: Request) {
        when (val effect = request.effect) {
            is Effect.Render -&gt; {
                this.view = ViewModel.bincodeDeserialize(view())
            }

            is Effect.Http -&gt; {
                val response = requestHttp(httpClient, effect.value)

                val effects =
                    handleResponse(
                        request.id.toUInt(),
                        HttpResult.Ok(response).bincodeSerialize()
                    )

                val requests = Requests.bincodeDeserialize(effects)
                for (request in requests) {
                    processEffect(request)
                }
            }

            is Effect.ServerSentEvents -&gt; {
                requestSse(sseClient, effect.value) { response -&gt;
                    val effects =
                        handleResponse(request.id.toUInt(), response.bincodeSerialize())

                    val requests = Requests.bincodeDeserialize(effects)
                    for (request in requests) {
                        processEffect(request)
                    }
                }
            }
        }
    }
}

</code></pre>
<h2 id="the-ui-components"><a class="header" href="#the-ui-components">The UI components</a></h2>
<p>Crux can work with any platform-specific UI library. We think it works best with
modern declarative UI frameworks such as
<a href="https://developer.apple.com/xcode/swiftui/">SwiftUI</a> on iOS,
<a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a> on Android, and
<a href="https://reactjs.org/">React</a>/<a href="https://vuejs.org/">Vue</a> or a Wasm based
framework (like <a href="https://yew.rs/">Yew</a>) on the web.</p>
<p>These frameworks are all pretty much identical. If you're familiar with one, you
can work out the others easily. In the examples on this page, we'll work in an
Android shell with Kotlin.</p>
<p>The components are bound to the view model, and they send events to the core.</p>
<p>We've already seen a "hello world" example when we were
<a href="guide/../getting_started/Android/android.html#create-some-ui-and-run-in-the-simulator">setting up an Android project</a>.
Rather than print that out again here, we'll just look at how we need to enhance
it to work with Kotlin coroutines. We'll probably need to do this with any real
shell, because the update function that dispatches side effect requests from the
core will likely need to be <code>suspend</code>.</p>
<p>This is the <code>View</code> from the
<a href="https://github.com/redbadger/crux/blob/master/examples/counter/Android/app/src/main/java/com/example/counter/MainActivity.kt">Counter example</a>
in the Crux repository.</p>
<pre><code class="language-kotlin">@Composable
fun View(model: Model = viewModel()) {
    val coroutineScope = rememberCoroutineScope()
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier
            .fillMaxSize()
            .padding(10.dp),
    ) {
        Text(text = "Crux Counter Example", fontSize = 30.sp, modifier = Modifier.padding(10.dp))
        Text(text = "Rust Core, Kotlin Shell (Jetpack Compose)", modifier = Modifier.padding(10.dp))
        Text(text = model.view.text, color = if(model.view.confirmed) { Color.Black } else { Color.Gray }, modifier = Modifier.padding(10.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(10.dp)) {
            Button(
                onClick = { coroutineScope.launch { model.update(CoreMessage.Event(Evt.Decrement())) } },
                colors = ButtonDefaults.buttonColors(containerColor = Color.hsl(44F, 1F, 0.77F))
            ) { Text(text = "Decrement", color = Color.DarkGray) }
            Button(
                onClick = { coroutineScope.launch { model.update(CoreMessage.Event(Evt.Increment())) } },
                colors =
                ButtonDefaults.buttonColors(
                    containerColor = Color.hsl(348F, 0.86F, 0.61F)
                )
            ) { Text(text = "Increment", color = Color.White) }
        }
    }
}
</code></pre>
<p>Notice that the first thing we do is create a CoroutineScope that is scoped to
the lifetime of the View (i.e. will be destroyed when the <code>View</code> component is
unmounted). Then we use this scope to launch asynchronous tasks to call the
<code>update</code> method with the specific event.
<code>Button(onClick = { coroutineScope.launch { model.update(CoreMessage.Event(Evt.Increment())) } })</code>.
We can't call <code>update</code> directly, because it is <code>suspend</code> so we need to be in an
asynchronous context to do so.</p>
<h2 id="the-capabilities"><a class="header" href="#the-capabilities">The capabilities</a></h2>
<p>We want the shell to be as thin as possible, so we need to write as little
platform-specific code as we can because this work has to be duplicated for each
platform.</p>
<p>In general, the more domain-aligned our capabilities are, the more code we'll
write. When our capabilities are generic, and closer to the technical end of the
spectrum, we get to write the least amount of shell code to support them.
Getting the balance right can be tricky, and the right answer might be different
depending on context. Obviously the <code>Http</code> capability is very generic, but a CMS
capability, for instance, might well be much more specific.</p>
<p>The shell-side code for the <code>Http</code> capability can be very small. A (very) naive
implementation for Android might look like this:</p>
<pre><code class="language-kotlin">package com.example.counter

import com.example.counter.shared_types.HttpHeader
import com.example.counter.shared_types.HttpRequest
import com.example.counter.shared_types.HttpResponse
import com.novi.serde.Bytes
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.request.headers
import io.ktor.client.request.request
import io.ktor.http.HttpMethod
import io.ktor.util.flattenEntries

suspend fun requestHttp(
    client: HttpClient,
    request: HttpRequest,
): HttpResponse {
    val response = client.request(request.url) {
        this.method = HttpMethod(request.method)
        this.headers {
            for (header in request.headers) {
                append(header.name, header.value)
            }
        }
    }
    val bytes = Bytes.valueOf(response.body())
    val headers = response.headers.flattenEntries().map { HttpHeader(it.first, it.second) }
    return HttpResponse(response.status.value.toShort(), headers, bytes)
}

</code></pre>
<p>The shell-side code to support a capability (or "Port" in "Ports and Adapters"),
is effectively just an "Adapter" (in the same terminology) to the native APIs.
Note that it's the shell's responsibility to cater for threading and/or async
coroutine requirements (so the above Kotlin function is <code>suspend</code> for this
reason).</p>
<p>The above function can then be called by the shell when an effect is emitted
requesting an HTTP call. It can then post the response back to the core (along
with the <code>id</code> that is used by the core to tie the response up to its original
request):</p>
<pre><code class="language-kotlin">for (req in requests) when (val effect = req.effect) {
    is Effect.Http -&gt; {
        val response = requestHttp(httpClient, effect.value)

        val effects =
            handleResponse(
                request.id.toUInt(),
                HttpResult.Ok(response).bincodeSerialize()
            )

        val requests = Requests.bincodeDeserialize(effects)
        for (request in requests) {
            processEffect(request)
        }
    }
    // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composable-applications"><a class="header" href="#composable-applications">Composable Applications</a></h1>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="guide/composing.html#admonition-info"></a>
</div>
<div>
<p>Coming soon.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capability-runtime"><a class="header" href="#capability-runtime">Capability Runtime</a></h1>
<p>In the previous sections we focused on building applications in Crux and using
its public APIs to do so. In this and the following chapters, we'll look at how
the internals of Crux work, starting with the capability runtime.</p>
<p>The capability runtime is a set of components that processes effects, presenting
the two perspectives we previously mentioned:</p>
<ul>
<li>For the core, the shell appears to be a platform with a message based system
interface</li>
<li>For the shell, the core appears as a stateful library responding to events
with request for side-effects</li>
</ul>
<p>There are a few challenges to solve in order to facilitate this interface.
First, each run of the <code>update</code> function can call several capabilities. The
requested effects are expected to be emitted together, and each batch of effects
will be processed concurrently, so the calls can't be blocking. Second, each effect requested from
a capability may require multiple round-trips between the core and shell to
conclude and we don't want to require a call to <code>update</code> per round trip, so we
need some ability to "suspend" execution in capabilities while waiting for an
effect to be fulfilled. The ability to suspend effects introduces a new
challenge - effects started in a particular capability and suspended, once
resolved, need to continue execution in the same capability.</p>
<p>Given this concurrency and execution suspension, an async interface seems like a
good candidate. Capabilities request work from the shell, <code>.await</code> the results,
and continue their work when the result has arrived. The call to
<code>request_from_shell</code> or <code>stream_from_shell</code> translates into an effect request
returned from the current core "transaction" (one call to <code>process_event</code> or
<code>resolve</code>).</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="internals/runtime.html#admonition-note"></a>
</div>
<div>
<p>In this chapter, we will focus on the runtime and the core interface and ignore
the serialization, bridge and FFI, and return to them in the following sections.
The examples will assume a Rust based shell.</p>
</div>
</div>
<h2 id="async-runtime"><a class="header" href="#async-runtime">Async runtime</a></h2>
<p>One of the fairly unique aspects of Rust's async is the fact that it doesn't
come with a bundled runtime. This is recognising that asynchronous execution is
useful in various different scenarios, and no one runtime can serve all of them.
Crux takes advantage of this and brings its own runtime, tailored to the
execution of side-effects on top of a message based interface.</p>
<p>For a deeper background on Rust's async architecture, we recommend the
<a href="https://rust-lang.github.io/async-book/">Asynchronous Programming in Rust</a>
book, especially the chapter about
<a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">executing futures and tasks</a>.
We will assume you are familiar with the basic ideas and mechanics of async
here.</p>
<p>The job of an async runtime is to manage a number of tasks, each driving one
future to completion. This management is done by an executor, which is
responsible for scheduling the futures and <code>poll</code>ing them <em>at the right time</em> to
drive their execution forward. Most "grown up" runtimes will do this on a number
of threads in a thread pool, but in Crux, we run in the context of a single
function call (of the app's <code>update</code> function) and potentially in a webassembly
context which is single threaded anyway, so our baby runtime only needs to poll
all the tasks sequentially, to see if any of them need to continue.</p>
<p>Polling all the tasks would work, and in our case wouldn't even be that
inefficient, but the async system is set up to avoid unnecessary polling of
futures with one additional concept - wakers. A waker is a mechanism which can
be used to signal to the executor that something that a given task is waiting on
has changed, and the task's future should be polled, because it will be able to
proceed. This is how "at the right time" from the above paragraph is decided.</p>
<p>In our case there's a single situation which causes such a change - a result has
arrived from the shell, for a particular effect requested earlier.</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="internals/runtime.html#admonition-warning"></a>
</div>
<div>
<p>Always use the capability APIs provided by Crux for async work (see the
<a href="internals/../guide/capability_apis.html">capabilities</a> chapter). Using other async APIs can
lead to unexpected behaviour, because the resulting futures are not tied to crux
effects. Such futures will resolve, but only after the next shell request causes
the crux executor to execute.</p>
</div>
</div>
<h2 id="one-effects-life-cycle"><a class="header" href="#one-effects-life-cycle">One effect's life cycle</a></h2>
<p>So, step by step, our strategy for the capabilities to handle effects is:</p>
<ol>
<li>A capability <code>spawn</code>s a task and submits a future with some code to run</li>
<li>The new task is scheduled to be polled next time the executor runs</li>
<li>The executor goes through the list of ready tasks until it gets to our task
and polls it</li>
<li>The future runs to the point where the first async call is <code>await</code>ed. In
capabilities, this <em>should</em> only be a future returned from one of the calls
to request something from the shell, or a future resulting from a composition
of such futures (through async method calls or combinators like <code>select</code> or
<code>join</code>).</li>
<li>The shell request future's first step is to create the request and prepare it
to be sent. We will look at the mechanics of the sending shortly, but for now
it's only important that part of this request is a callback used to resolve
it.</li>
<li>The request future, as part of the first poll by the executor, sends the
request to be handed to the shell. As there is no result from the shell yet,
it returns a pending state and the task is suspended.</li>
<li>The request is passed on to the shell to resolve (as a return value from
<code>process_event</code> or <code>resolve</code>)</li>
<li>Eventually, the shell has a result ready for the request and asks the core to
<code>resolve</code> the request.</li>
<li>The request callback mentioned above is executed, puts the provided result in
the future's mutable state, and calls the future's waker, also stored in the
future's state, to wake the future up. The waker enqueues the future for
processing on the executor.</li>
<li>The executor runs again (asked to do so by the core's <code>resolve</code> API after
calling the callback), and polls the awoken future.</li>
<li>the future sees there is now a result available and continues the execution
of the original task until a further await or until completion.</li>
</ol>
<p>The cycle may repeat a few times, depending on the capability implementation,
but eventually the original task completes and is removed.</p>
<p>This is probably a lot to take in, but the basic gist is that capability futures
(the ones submitted to <code>spawn</code>) always pause on request futures (the ones
returned from <code>request_from_shell</code> et al.), which submit requests. Resolving
requests updates the state of the original future and wakes it up to continue
execution.</p>
<p>With that in mind we can look at the individual moving parts and how they
communicate.</p>
<h2 id="spawning-tasks-on-the-executor"><a class="header" href="#spawning-tasks-on-the-executor">Spawning tasks on the executor</a></h2>
<p>The first step for anything to happen is spawning a task from a capability. Each
capability is created with a <code>CapabilityContext</code>. This is the definition:</p>
<pre><code class="language-rust no_run noplayground">pub struct CapabilityContext&lt;Op, Event&gt;
where
    Op: Operation,
{
    inner: std::sync::Arc&lt;ContextInner&lt;Op, Event&gt;&gt;,
}

struct ContextInner&lt;Op, Event&gt;
where
    Op: Operation,
{
    shell_channel: Sender&lt;Request&lt;Op&gt;&gt;,
    app_channel: Sender&lt;Event&gt;,
    spawner: executor::Spawner,
}</code></pre>
<p>There are a couple of sending ends of channels for requests and events, which we
will get to soon, and also a spawner, from the executor module. The <code>Spawner</code>
looks like this:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Clone)]
pub struct Spawner {
    future_sender: Sender&lt;BoxFuture&gt;,
}</code></pre>
<p>also holding a sending end of a channel, this one for <code>Task</code>s.</p>
<p>Tasks are a fairly simple data structure, holding a future and another sending
end of the tasks channel, because tasks need to be able to submit themselves
when awoken.</p>
<pre><code class="language-rust no_run noplayground"></code></pre>
<p>Tasks are spawned by the Spawner as follows:</p>
<pre><code class="language-rust no_run noplayground">impl Spawner {
    pub fn spawn(&amp;self, future: impl Future&lt;Output = ()&gt; + 'static + Send) {
        let future = future.boxed();
        self.future_sender
            .send(future)
            .expect("unable to spawn an async task, task sender channel is disconnected.")
    }
}</code></pre>
<p>after constructing a task, it is submitted using the task sender.</p>
<p>The final piece of the puzzle is the executor itself:</p>
<pre><code class="language-rust no_run noplayground">pub(crate) struct QueuingExecutor {
    spawn_queue: Receiver&lt;BoxFuture&gt;,
    ready_queue: Receiver&lt;TaskId&gt;,
    ready_sender: Sender&lt;TaskId&gt;,
    tasks: Mutex&lt;Slab&lt;Option&lt;BoxFuture&gt;&gt;&gt;,
}</code></pre>
<p>This is the receiving end of the channel from the spawner.</p>
<p>The executor has a single public method, <code>run_all</code>:</p>
<pre><code class="language-rust no_run noplayground">impl QueuingExecutor {
    pub fn run_all(&amp;self) {
        // we read off both queues and execute the tasks we receive.
        // Since either queue can generate work for the other queue,
        // we read from them in a loop until we are sure both queues
        // are exhausted
        let mut did_some_work = true;

        while did_some_work {
            did_some_work = false;
            while let Ok(task) = self.spawn_queue.try_recv() {
                let task_id = self
                    .tasks
                    .lock()
                    .expect("Task slab poisoned")
                    .insert(Some(task));
                self.run_task(TaskId(task_id.try_into().expect("TaskId overflow")));
                did_some_work = true;
            }
            while let Ok(task_id) = self.ready_queue.try_recv() {
                match self.run_task(task_id) {
                    RunTask::Unavailable =&gt; {
                        // We were unable to run the task as it is (presumably) being run on
                        // another thread. We re-queue the task for 'later' and do NOT set
                        // `did_some_work = true`. That way we will keep looping and doing work
                        // until all remaining work is 'unavailable', at which point we will bail
                        // out of the loop, leaving the queued work to be finished by another thread.
                        // This strategy should avoid dropping work or busy-looping
                        self.ready_sender.send(task_id).expect("could not requeue");
                    }
                    RunTask::Missing =&gt; {
                        // This is possible if a naughty future sends a wake notification while
                        // still running, then runs to completion and is evicted from the slab.
                        // Nothing to be done.
                    }
                    RunTask::Suspended | RunTask::Completed =&gt; did_some_work = true,
                }
            }
        }
    }

    fn run_task(&amp;self, task_id: TaskId) -&gt; RunTask {
        let mut lock = self.tasks.lock().expect("Task slab poisoned");
        let Some(task) = lock.get_mut(*task_id as usize) else {
            return RunTask::Missing;
        };
        let Some(mut task) = task.take() else {
            // the slot exists but the task is missing - presumably it
            // is being executed on another thread
            return RunTask::Unavailable;
        };

        // free the mutex so other threads can make progress
        drop(lock);

        let waker = Arc::new(TaskWaker {
            task_id,
            sender: self.ready_sender.clone(),
        })
        .into();
        let context = &amp;mut Context::from_waker(&amp;waker);

        // poll the task
        if task.as_mut().poll(context).is_pending() {
            // If it's still pending, put the future back in the slot
            self.tasks
                .lock()
                .expect("Task slab poisoned")
                .get_mut(*task_id as usize)
                .expect("Task slot is missing")
                .replace(task);
            RunTask::Suspended
        } else {
            // otherwise the future is completed and we can free the slot
            self.tasks.lock().unwrap().remove(*task_id as usize);
            RunTask::Completed
        }
    }
}

enum RunTask {
    Missing,
    Unavailable,
    Suspended,
    Completed,
}
</code></pre>
<p>besides the locking and waker mechanics, the gist is quite simple - while there
are tasks in the ready_queue, poll the future held in each one.</p>
<p>The last interesting bit of this part is how the waker is provided to the <code>poll</code>
call. The <code>waker_ref</code> creates a waker which, when asked to wake up, will call
this method on the task:</p>
<pre><code class="language-rust no_run noplayground">impl Wake for TaskWaker {
    fn wake(self: Arc&lt;Self&gt;) {
        self.wake_by_ref();
    }

    fn wake_by_ref(self: &amp;Arc&lt;Self&gt;) {
        // This send can fail if the executor has been dropped.
        // In which case, nothing to do
        let _ = self.sender.send(self.task_id);
    }
}</code></pre>
<p>this is where the task resubmits itself for processing on the next run.</p>
<p>While there are a lot of moving pieces involved, the basic mechanics are
relatively straightforward - tasks are submitted either by the spawner, or the
futures awoken by arriving responses to the requests they submitted. The queue
of tasks is processed whenever <code>run_all</code> is called on the executor. This happens
in the <code>Core</code> API implementation. Both <code>process_event</code> and <code>resolve</code> call
<code>run_all</code> after their respective task - calling the app's <code>update</code> function, or
resolving the given task.</p>
<p>Now we know how the futures get executed, suspended and resumed, we can examine
the flow of information between capabilities and the Core API calls layered on
top.</p>
<h2 id="requests-flow-from-capabilities-to-the-shell"><a class="header" href="#requests-flow-from-capabilities-to-the-shell">Requests flow from capabilities to the shell</a></h2>
<p>The key to understanding how the effects get processed and executed is to name
all the various pieces of information, and discuss how they are wrapped in each
other.</p>
<p>The basic inner piece of the effect request is an <em>operation</em>. This is the
intent which the capability is submitting to the shell. Each operation has an
associated <em>output</em> value, with which the operation request can be resolved.
There are multiple capabilities in each app, and in order for the shell to
easily tell which capability's effect it needs to handle, we wrap the operation
in an <em>effect</em>. The <code>Effect</code> type is a generated enum based on the app's set of
capabilities, with one variant per capability. It allows us to multiplex (or
type erase) the different typed operations into a single type, which can be
<code>match</code>ed on to process the operations.</p>
<p>Finally, the effect is wrapped in a <em>request</em> which carries the effect, and an
associated <em>resolve</em> callback to which the output will eventually be given. We
discussed this callback in the previous section - its job is to update the
paused future's state and resume it. The request is the value passed to the
shell, and used as both the description of the effect intent, and the "token"
used to resolve it.</p>
<p>Now we can look at how all this wrapping is facilitated. Recall from the
previous section that each capability has access to a <code>CapabilityContext</code>, which
holds a sending end of two channels, one for events - the <code>app_channel</code> and one
for requests - the <code>shell_channel</code>, whose type is <code>Sender&lt;Request&lt;Op&gt;&gt;</code>. These
channels serve both as thread synchronisation and queueing mechanism between the
capabilities and the core of crux. As you can see, the requests expected are
typed for the capability's operation type.</p>
<p>Looking at the core itself, we see their <code>Receiver</code> ends.</p>
<pre><code class="language-rust no_run noplayground">pub struct Core&lt;Ef, A&gt;
where
    A: App,
{
    // WARNING: The user controlled types _must_ be defined first
    // so that they are dropped first, in case they contain coordination
    // primitives which attempt to wake up a future when dropped. For that
    // reason the executor _must_ outlive the user type instances

    // user types
    model: RwLock&lt;A::Model&gt;,
    capabilities: A::Capabilities,
    app: A,

    // internals
    requests: Receiver&lt;Ef&gt;,
    capability_events: Receiver&lt;A::Event&gt;,
    executor: QueuingExecutor,
}</code></pre>
<p>One detail to note is that the receiving end of the requests channel is a
<code>Receiver&lt;Ef&gt;</code>. The channel has an additional feature - it can map between the
input types and output types, and, in this case, serve as a multiplexer,
wrapping the operation in the corresponding Effect variant. Each sending end is
specialised for the respective capability, but the receiving end gets an already
wrapped <code>Effect</code>.</p>
<h2 id="a-single-update-cycle"><a class="header" href="#a-single-update-cycle">A single update cycle</a></h2>
<p>To piece all these things together, lets look at processing a single call from
the shell. Both <code>process_event</code> and <code>resolve</code> share a common step advancing the
capability runtime.</p>
<p>Here is <code>process_event</code>:</p>
<pre><code class="language-rust no_run noplayground">    pub fn process_event(&amp;self, event: A::Event) -&gt; Vec&lt;Ef&gt; {
        let mut model = self.model.write().expect("Model RwLock was poisoned.");

        self.app.update(event, &amp;mut model, &amp;self.capabilities);

        // drop the model here, we don't want to hold the lock for the process() call
        drop(model);

        self.process()
    }</code></pre>
<p>and here is <code>resolve</code>:</p>
<pre><code class="language-rust no_run noplayground">    pub fn resolve&lt;Op&gt;(&amp;self, request: &amp;mut Request&lt;Op&gt;, result: Op::Output) -&gt; Vec&lt;Ef&gt;
    where
        Op: Operation,
    {
        let resolve_result = request.resolve(result);
        debug_assert!(resolve_result.is_ok());

        self.process()
    }</code></pre>
<p>The interesting things happen in the common <code>process</code> method:</p>
<pre><code class="language-rust no_run noplayground">    pub(crate) fn process(&amp;self) -&gt; Vec&lt;Ef&gt; {
        self.executor.run_all();

        while let Some(capability_event) = self.capability_events.receive() {
            let mut model = self.model.write().expect("Model RwLock was poisoned.");
            self.app
                .update(capability_event, &amp;mut model, &amp;self.capabilities);
            drop(model);
            self.executor.run_all();
        }

        self.requests.drain().collect()
    }</code></pre>
<p>First, we run all ready tasks in the executor. There can be new tasks ready
because we just ran the app's update function (which may have spawned some task
via capability calls) or resolved some effects (which woke up their suspended
futures).</p>
<p>Next, we drain the events channel (where events are submitted from capabilities
by <code>context.update_app</code>) and one by one, send them to the <code>update</code> function,
running the executor after each one.</p>
<p>Finally, we collect all of the effect requests submitted in the process and
return them to the shell.</p>
<h2 id="resolving-requests"><a class="header" href="#resolving-requests">Resolving requests</a></h2>
<p>We've now seen everything other than the mechanics of resolving requests. This
is ultimately just a callback carried by the request, but for additional type
safety, it is tagged by the expected number of resolutions</p>
<pre><code class="language-rust no_run noplayground">type ResolveOnce&lt;Out&gt; = Box&lt;dyn FnOnce(Out) + Send&gt;;
type ResolveMany&lt;Out&gt; = Box&lt;dyn Fn(Out) -&gt; Result&lt;(), ()&gt; + Send&gt;;

/// Resolve is a callback used to resolve an effect request and continue
/// one of the capability Tasks running on the executor.
pub(crate) enum Resolve&lt;Out&gt; {
    Never,
    Once(ResolveOnce&lt;Out&gt;),
    Many(ResolveMany&lt;Out&gt;),
}</code></pre>
<p>We've already mentioned the resolve function itself briefly, but for
completeness, here's an example from <code>request_from_shell</code>:</p>
<pre><code class="language-rust no_run noplayground">        let request = Request::resolves_once(operation, move |result| {
            let Some(shared_state) = callback_shared_state.upgrade() else {
                // The ShellRequest was dropped before we were called, so just
                // do nothing.
                return;
            };

            let mut shared_state = shared_state.lock().unwrap();

            // Attach the result to the shared state of the future
            shared_state.result = Some(result);
            // Signal the executor to wake the task holding this future
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });</code></pre>
<p>Bar the locking and sharing mechanics, all it does is update the state of the
future (<code>shared_state</code>) and then calls <code>wake</code> on the future's waker to schedule
it on the executor.</p>
<p>In the next chapter, we will look at how this process changes when Crux is used
via an FFI interface where requests and responses need to be serialised in order
to pass across the language boundary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-bridge"><a class="header" href="#ffi-bridge">FFI bridge</a></h1>
<p>In the previous chapter, we saw how the capability runtime facilitates the
orchestration of effect processing by the shell. We looked at the simpler
scenario where the shell was built in Rust. Now we'll extend this to the more
common scenario where the shell is written in a different language and the core
APIs are called over a Foreign Function Interface, passing events, requests and
responses back and forth, serialised as bytes.</p>
<h2 id="the-ffi-bridge"><a class="header" href="#the-ffi-bridge">The FFI bridge</a></h2>
<p>The FFI bridge has two key parts, the serialisation part converting from typed
effect requests to serializable types, and the FFI implementation itself,
facilitated by <a href="https://github.com/mozilla/uniffi-rs">UniFFI</a>.</p>
<p>The serialisation part is facilitated by the <code>Bridge</code>. It is a wrapper for the
<code>Core</code> with its own definition of <code>Request</code>. Its API is very similar to the
<code>Core</code> API - it has an identical set of methods, but their type signatures are
different.</p>
<p>For example, here is <code>Core::resolve</code></p>
<pre><code class="language-rust no_run noplayground">    pub fn resolve&lt;Op&gt;(&amp;self, request: &amp;mut Request&lt;Op&gt;, result: Op::Output) -&gt; Vec&lt;Ef&gt;
    where
        Op: Operation,</code></pre>
<p>and here's its counterpart, <code>Bridge::handle_response</code></p>
<pre><code class="language-rust no_run noplayground">    pub fn handle_response(&amp;self, id: u32, output: &amp;[u8]) -&gt; Vec&lt;u8&gt;</code></pre>
<p>where the core expects to be given a <code>Request&lt;Op&gt;</code> to resolve, the bridge
expects a <code>id</code> - a unique identifier of the request being resolved.</p>
<p>This makes sense - the <code>Request</code>s include callback closures working with the
capability runtime, they can't be easily serialised and sent back and forth
across the language boundary. Instead, the bridge "parks" them in a registry, to
be picked up later. Like in a theatre cloakroom, the registry returns a unique
number under which the request is stored.</p>
<p>The implementation of the serialization/deserialization process is slightly
complicated by the fact that Crux allows you to supply your own serializer and
deserializer should you need to, so the actual bridge implementation does not
work on bytes but on serializers. The <code>Bridge</code> type used in examples and all the
documentation is a default implementation, which uses bincode serialization,
which is also supported by the <a href="internals/./typegen.html">type generation subsystem</a>.</p>
<p>We won't go into the detail of working with Serde and the
<a href="https://docs.rs/erased-serde/"><code>erased_serde</code></a> crate to make all the
serialization happen without leaking deserialization lifetimes out of the
bridge. You can read the implementation of <code>BridgeWithSerializer</code> if you're
interested in the gory details. For our purposes, the type definition will
suffice.</p>
<pre><code class="language-rust no_run noplayground">pub struct BridgeWithSerializer&lt;Eff, A&gt;
where
    Eff: Effect,
    A: App,
{
    core: Core&lt;Eff, A&gt;,
    registry: ResolveRegistry,
}</code></pre>
<p>The bridge holds an instance of the <code>Core</code> and a <code>ResolveRegistry</code> to store the
effect requests in.</p>
<p>The processing of the update loop is quite similar to the Core update loop:</p>
<ul>
<li>When a serialized event arrives, it is deserialized and passed to the <code>Core</code>'s
<code>process_event</code></li>
<li>When a request response arrives, its id is forwarded to the
<code>ResolveRegistry</code>'s <code>resume</code> method, and the <code>Core</code>'s <code>process</code> method is
called to run the capability runtime</li>
</ul>
<p>You may remember that both these calls return effect requests. The remaining
step is to store these in the registry, using the registry's <code>register</code> method,
exchanging the core <code>Request</code> for a bridge variant, which looks like this:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Serialize, Deserialize)]
pub struct Request&lt;Eff&gt;
where
    Eff: Serialize,
{
    pub id: EffectId,
    pub effect: Eff,
}</code></pre>
<p>Unlike the core request, this does not include any closures and is fully
serializable.</p>
<h2 id="resolveregistry"><a class="header" href="#resolveregistry">ResolveRegistry</a></h2>
<p>It is worth pausing for a second on the resolve registry. There is one tricky
problem to solve here - storing the generic <code>Request</code>s in a single store. We get
around this by making the <code>register</code> method generic and asking the effect to
"serialize" itself.</p>
<pre><code class="language-rust no_run noplayground">    pub fn register&lt;Eff&gt;(&amp;self, effect: Eff) -&gt; Request&lt;Eff::Ffi&gt;
    where
        Eff: Effect,
    {
        let (effect, resolve) = effect.serialize();

        let id = self
            .0
            .lock()
            .expect("Registry Mutex poisoned.")
            .insert(resolve);

        Request {
            id: EffectId(id.try_into().expect("EffectId overflow")),
            effect,
        }
    }</code></pre>
<p>this is named based on our intent, not really based on what actually happens.
The method comes from an <code>Effect</code> trait:</p>
<pre><code class="language-rust no_run noplayground">pub trait Effect: Send + 'static {
    /// Ffi is an enum with variants corresponding to the Effect variants
    /// but instead of carrying a `Request&lt;Op&gt;` they carry the `Op` directly
    type Ffi: Serialize;

    /// Converts the `Effect` into its FFI counterpart and returns it alongside
    /// a deserializing version of the resolve callback for the request that the
    /// original `Effect` was carrying.
    ///
    /// You should not need to call this method directly. It is called by
    /// the [`Bridge`](crate::bridge::Bridge)
    fn serialize(self) -&gt; (Self::Ffi, ResolveSerialized);
}</code></pre>
<p>Like the <code>Effect</code> type which implements this trait, the implementation is macro
generated, based on the Capabilities used by your application. We will look at
how this works in the <a href="internals/./effect.html"><code>Effect type</code></a> chapter.</p>
<p>The type signature of the method gives us a hint though - it converts the normal
<code>Effect</code> into a serializable counterpart, alongside something with a
<code>ResolveSerialized</code> type. This is stored in the registry under an id, and the effect and the id are returned as the bridge version
of a <code>Request</code>.</p>
<p>The definition of the <code>ResolveSerialized</code> type is a little bit convoluted:</p>
<pre><code class="language-rust no_run noplayground">type ResolveOnceSerialized = Box&lt;dyn FnOnce(&amp;mut dyn erased_serde::Deserializer) + Send&gt;;
type ResolveManySerialized =
    Box&lt;dyn FnMut(&amp;mut dyn erased_serde::Deserializer) -&gt; Result&lt;(), ()&gt; + Send&gt;;

/// A deserializing version of Resolve
///
/// ResolveSerialized is a separate type because lifetime elision doesn't work
/// through generic type arguments. We can't create a ResolveRegistry of
/// Resolve&lt;&amp;[u8]&gt; without specifying an explicit lifetime.
/// If you see a better way around this, please open a PR.
pub enum ResolveSerialized {
    Never,
    Once(ResolveOnceSerialized),
    Many(ResolveManySerialized),
}</code></pre>
<p>but the gist of it is that it is a mirror of the <code>Resolve</code> type we already know,
except it takes a Deserializer. More about this serialization trickery in the
next chapter.</p>
<h2 id="ffi-interface"><a class="header" href="#ffi-interface">FFI interface</a></h2>
<p>The final piece of the puzzle is the FFI interface itself. All it does is expose
the bridge API we've seen above.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="internals/bridge.html#admonition-note"></a>
</div>
<div>
<p>You will see that this part, alongside the type generation, is a fairly
complicated constellation of various existing tools and libraries, which has
a number of rough edges. It is likely that we will explore replacing this
part of Crux with a tailor made FFI bridge in the future. If/when we do, we will
do our best to provide a smooth migration path.</p>
</div>
</div>
<p>Here's a typical app's shared crate <code>src/lib.rs</code> file:</p>
<pre><code class="language-rust no_run noplayground">pub mod app;

use lazy_static::lazy_static;
use wasm_bindgen::prelude::wasm_bindgen;

pub use crux_core::{bridge::Bridge, Core, Request};

pub use app::*;

// TODO hide this plumbing

uniffi::include_scaffolding!("shared");

lazy_static! {
    static ref CORE: Bridge&lt;Effect, App&gt; = Bridge::new(Core::new());
}

#[wasm_bindgen]
pub fn process_event(data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    CORE.process_event(data)
}

#[wasm_bindgen]
pub fn handle_response(id: u32, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    CORE.handle_response(id, data)
}

#[wasm_bindgen]
pub fn view() -&gt; Vec&lt;u8&gt; {
    CORE.view()
}</code></pre>
<p>Ignore the TODO, we will get to that eventually, I promise. There are two forms
of FFI going on - the <code>wasm_bindgen</code> annotations on the three functions,
exposing them when built as webassembly, and also the line saying</p>
<pre><code class="language-rust no_run noplayground">uniffi::include_scaffolding!("shared");</code></pre>
<p>which refers to the <code>shared.udl</code> file in the same folder</p>
<pre><code>namespace shared {
  bytes process_event([ByRef] bytes msg);
  bytes handle_response(u32 id, [ByRef] bytes res);
  bytes view();
};
</code></pre>
<p>This is UniFFI's interface definition used to generate the scaffolding for the
FFI interface - both the externally callable functions in the <code>shared</code> library,
and their counterparts in the "foreign" languages (like Swift or Kotlin).</p>
<p>The scaffolding is built in the <code>build.rs</code> script of the crate</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    uniffi::generate_scaffolding("./src/shared.udl").unwrap();
}</code></pre>
<p>The foreign language code is built by an additional binary target for the same
crate, in <code>src/bin/uniffi-bindgen.rs</code></p>
<pre><code class="language-rust no_run noplayground">fn main() {
    uniffi::uniffi_bindgen_main()
}</code></pre>
<p>this builds a CLI which can be used as part of the build process for clients of
the library to generate the code.</p>
<p>The details of this process are well documented
<a href="https://mozilla.github.io/uniffi-rs/Getting_started.html">in UniFFI's tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-effect-type"><a class="header" href="#the-effect-type">The Effect type</a></h1>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="internals/effect.html#admonition-info"></a>
</div>
<div>
<p>Coming soon.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-generation"><a class="header" href="#type-generation">Type generation</a></h1>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="internals/typegen.html#admonition-info"></a>
</div>
<div>
<p>Coming soon.</p>
</div>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
