<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interface between core and shell - Crux: Cross-platform app development in Rust</title>


        <!-- Custom HTML head -->
        <script async defer src="https://beampipe.io/js/tracker.js" data-beampipe-domain="redbadger.github.io"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Crux: Cross-platform app development in Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/redbadger/crux/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/redbadger/crux/edit/master/docs/src/guide/message_interface.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="message-interface-between-core-and-shell"><a class="header" href="#message-interface-between-core-and-shell">Message interface between core and shell</a></h1>
<p>So far in this book, we've been taking the perspective of being inside the core
looking out. It feels like it's now time to be in the shell, looking in.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note"></a>
</div>
<div>
<p>Interestingly, we think this is also the way to approach building apps with Crux. For any one feature, start in the middle and get your behaviour established first. Write the tests without the UI and the other side-effects in the way. Give yourself maximum confidence that the feature works <em>exactly</em> as you expect before you muddy the water with UI components, and their look and feel.</p>
</div>
</div>
<p>OK, let's talk about the shell.</p>
<p>The shell only has two responsibilities:</p>
<ol>
<li>Laying out the UI components</li>
<li>Supporting the app's capabilities</li>
</ol>
<p>We'll look at these separately. But first let's remind ourselves of how we
interact with the core (now would be a good time to read
<a href="../getting_started/core.html">Shared core and types</a> if you haven't already).</p>
<h2 id="the-message-protocol"><a class="header" href="#the-message-protocol">The message protocol</a></h2>
<p>The interface is message based, and uses serialization to pass data back and
forth. The core exports the types for all the data so that it can be used and
created on the shell side with safety.</p>
<p>An <code>Event</code> can be passed in directly, as-is. Processing of <code>Effect</code>s is a little
more complicated, because the core needs to be able to pair the outcomes of the
effects with the original capability call, so it can return them to the right
caller. To do that, effects are wrapped in a <code>Request</code>, which tags them with an
Id. To respond, the same Id needs to be passed back in.</p>
<p>Requests from the core are emitted serialized, and need to be deserialized
first. Both events and effect outputs need to be serialized before being passed
back to the core.</p>
<div id="admonition-sharp-edge" class="admonition admonish-warning" role="note" aria-labelledby="admonition-sharp-edge-title">
<div class="admonition-title">
<div id="admonition-sharp-edge-title">
<p>Sharp edge</p>
</div>
<a class="admonition-anchor-link" href="#admonition-sharp-edge"></a>
</div>
<div>
<p>It is likely that this will become an implementation detail and instead, Crux will provide a more ergonomic shell-side API for the interaction, hiding both the EffectId pairing and the serialization (and allowing us to iterate on the FFI implementation which, we think, could work better).</p>
</div>
</div>
<h2 id="the-core-interface"><a class="header" href="#the-core-interface">The core interface</a></h2>
<p>There are only three touch-points with the core.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn process_event(data: &amp;[u8]) -&gt; Vec&lt;u8&gt; { todo!() }
pub fn handle_response(id: u32, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; { todo!() }
pub fn view() -&gt; Vec&lt;u8&gt; { todo!() }
<span class="boring">}</span></code></pre></pre>
<p>The <code>process_event</code> function takes a serialized <code>Event</code> (from a UI interaction)
and returns a serialized vector of <code>Request</code>s that the shell can dispatch to the
relevant capability's shell-side code (see the section below on how the shell
handles capabilities).</p>
<p>The <code>handle_response</code> function, used to return capability output back into the
core, is similar to <code>process_event</code> except that it also takes a <code>id</code>, which
ties the output (for example a HTTP response) being submitted with it's original
<code>Effect</code> which started it (and the corresponding request which the core wrapped
it in).</p>
<p>The <code>view</code> function simply retrieves the serialized view model (to which the UI
is bound) and is called by the shell after it receives a <code>Render</code> request. The
view model is a projection of the app's state â€“ it reflects what information the
Core wants displayed on screen.</p>
<p>You're probably thinking, "Whoa! I just see slices and vectors of bytes, where's
the type safety?". Well, the answer is that we also generate all the types that
pass through the bridge, for each language, along with serialization and
deserialization helpers. This is done by the <code>serde-generate</code> crate (see the
section on
<a href="../getting_started/core.html#create-the-shared-types-crate">Create the shared types crate</a>).</p>
<div id="admonition-sharp-edge-1" class="admonition admonish-warning" role="note" aria-labelledby="admonition-sharp-edge-1-title">
<div class="admonition-title">
<div id="admonition-sharp-edge-1-title">
<p>Sharp edge</p>
</div>
<a class="admonition-anchor-link" href="#admonition-sharp-edge-1"></a>
</div>
<div>
<p>For now we have to manually invoke the serialization code in the shell. At some point this may be abstracted away.</p>
</div>
</div>
<p>In this code snippet from the
<a href="https://github.com/redbadger/crux/blob/master/examples/counter/Android/app/src/main/java/com/example/counter/Core.kt">Counter example</a>,
notice that we call <code>processEvent</code> and <code>handleResponse</code> on the core depending on
whether we received an <code>Event</code> from the UI or from a capability, respectively.
Regardless of which core function we call, we get back a bunch of requests,
which we can iterate through and do the relevant thing (the following snippet
triggers a render of the UI, or makes an HTTP call, or launches a task to wait
for Server Sent Events, depending on what the core requested):</p>
<pre><code class="language-kotlin">class Core : androidx.lifecycle.ViewModel() {
    var view: ViewModel? by mutableStateOf(null)
        private set

    private val httpClient = HttpClient(CIO)
    private val sseClient = HttpClient(CIO) {
        engine {
            endpoint {
                keepAliveTime = 5000
                connectTimeout = 5000
                connectAttempts = 5
                requestTimeout = 0
            }
        }
    }

    init {
        viewModelScope.launch {
            update(Event.StartWatch())
        }
    }

    suspend fun update(event: Event) {
        val effects = processEvent(event.bincodeSerialize())

        val requests = Requests.bincodeDeserialize(effects)
        for (request in requests) {
            processEffect(request)
        }
    }

    private suspend fun processEffect(request: Request) {
        when (val effect = request.effect) {
            is Effect.Render -&gt; {
                this.view = ViewModel.bincodeDeserialize(view())
            }

            is Effect.Http -&gt; {
                val response = requestHttp(httpClient, effect.value)

                val effects =
                    handleResponse(
                        request.id.toUInt(),
                        HttpResult.Ok(response).bincodeSerialize()
                    )

                val requests = Requests.bincodeDeserialize(effects)
                for (request in requests) {
                    processEffect(request)
                }
            }

            is Effect.ServerSentEvents -&gt; {
                requestSse(sseClient, effect.value) { response -&gt;
                    val effects =
                        handleResponse(request.id.toUInt(), response.bincodeSerialize())

                    val requests = Requests.bincodeDeserialize(effects)
                    for (request in requests) {
                        processEffect(request)
                    }
                }
            }
        }
    }
}

</code></pre>
<h2 id="the-ui-components"><a class="header" href="#the-ui-components">The UI components</a></h2>
<p>Crux can work with any platform-specific UI library. We think it works best with
modern declarative UI frameworks such as
<a href="https://developer.apple.com/xcode/swiftui/">SwiftUI</a> on iOS,
<a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a> on Android, and
<a href="https://reactjs.org/">React</a>/<a href="https://vuejs.org/">Vue</a> or a Wasm based
framework (like <a href="https://yew.rs/">Yew</a>) on the web.</p>
<p>These frameworks are all pretty much identical. If you're familiar with one, you
can work out the others easily. In the examples on this page, we'll work in an
Android shell with Kotlin.</p>
<p>The components are bound to the view model, and they send events to the core.</p>
<p>We've already seen a "hello world" example when we were
<a href="../getting_started/Android/android.html#create-some-ui-and-run-in-the-simulator">setting up an Android project</a>.
Rather than print that out again here, we'll just look at how we need to enhance
it to work with Kotlin coroutines. We'll probably need to do this with any real
shell, because the update function that dispatches side effect requests from the
core will likely need to be <code>suspend</code>.</p>
<p>This is the <code>View</code> from the
<a href="https://github.com/redbadger/crux/blob/master/examples/counter/Android/app/src/main/java/com/example/counter/MainActivity.kt">Counter example</a>
in the Crux repository.</p>
<pre><code class="language-kotlin">@Composable
fun View(model: Model = viewModel()) {
    val coroutineScope = rememberCoroutineScope()
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier
            .fillMaxSize()
            .padding(10.dp),
    ) {
        Text(text = "Crux Counter Example", fontSize = 30.sp, modifier = Modifier.padding(10.dp))
        Text(text = "Rust Core, Kotlin Shell (Jetpack Compose)", modifier = Modifier.padding(10.dp))
        Text(text = model.view.text, color = if(model.view.confirmed) { Color.Black } else { Color.Gray }, modifier = Modifier.padding(10.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(10.dp)) {
            Button(
                onClick = { coroutineScope.launch { model.update(CoreMessage.Event(Evt.Decrement())) } },
                colors = ButtonDefaults.buttonColors(containerColor = Color.hsl(44F, 1F, 0.77F))
            ) { Text(text = "Decrement", color = Color.DarkGray) }
            Button(
                onClick = { coroutineScope.launch { model.update(CoreMessage.Event(Evt.Increment())) } },
                colors =
                ButtonDefaults.buttonColors(
                    containerColor = Color.hsl(348F, 0.86F, 0.61F)
                )
            ) { Text(text = "Increment", color = Color.White) }
        }
    }
}
</code></pre>
<p>Notice that the first thing we do is create a CoroutineScope that is scoped to
the lifetime of the View (i.e. will be destroyed when the <code>View</code> component is
unmounted). Then we use this scope to launch asynchronous tasks to call the
<code>update</code> method with the specific event.
<code>Button(onClick = { coroutineScope.launch { model.update(CoreMessage.Event(Evt.Increment())) } })</code>.
We can't call <code>update</code> directly, because it is <code>suspend</code> so we need to be in an
asynchronous context to do so.</p>
<h2 id="the-capabilities"><a class="header" href="#the-capabilities">The capabilities</a></h2>
<p>We want the shell to be as thin as possible, so we need to write as little
platform-specific code as we can because this work has to be duplicated for each
platform.</p>
<p>In general, the more domain-aligned our capabilities are, the more code we'll
write. When our capabilities are generic, and closer to the technical end of the
spectrum, we get to write the least amount of shell code to support them.
Getting the balance right can be tricky, and the right answer might be different
depending on context. Obviously the <code>Http</code> capability is very generic, but a CMS
capability, for instance, might well be much more specific.</p>
<p>The shell-side code for the <code>Http</code> capability can be very small. A (very) naive
implementation for Android might look like this:</p>
<pre><code class="language-kotlin">package com.example.counter

import com.example.counter.shared_types.HttpHeader
import com.example.counter.shared_types.HttpRequest
import com.example.counter.shared_types.HttpResponse
import com.novi.serde.Bytes
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.request.headers
import io.ktor.client.request.request
import io.ktor.http.HttpMethod
import io.ktor.util.flattenEntries

suspend fun requestHttp(
    client: HttpClient,
    request: HttpRequest,
): HttpResponse {
    val response = client.request(request.url) {
        this.method = HttpMethod(request.method)
        this.headers {
            for (header in request.headers) {
                append(header.name, header.value)
            }
        }
    }
    val bytes = Bytes.valueOf(response.body())
    val headers = response.headers.flattenEntries().map { HttpHeader(it.first, it.second) }
    return HttpResponse(response.status.value.toShort(), headers, bytes)
}

</code></pre>
<p>The shell-side code to support a capability (or "Port" in "Ports and Adapters"),
is effectively just an "Adapter" (in the same terminology) to the native APIs.
Note that it's the shell's responsibility to cater for threading and/or async
coroutine requirements (so the above Kotlin function is <code>suspend</code> for this
reason).</p>
<p>The above function can then be called by the shell when an effect is emitted
requesting an HTTP call. It can then post the response back to the core (along
with the <code>id</code> that is used by the core to tie the response up to its original
request):</p>
<pre><code class="language-kotlin">for (req in requests) when (val effect = req.effect) {
    is Effect.Http -&gt; {
        val response = requestHttp(httpClient, effect.value)

        val effects =
            handleResponse(
                request.id.toUInt(),
                HttpResult.Ok(response).bincodeSerialize()
            )

        val requests = Requests.bincodeDeserialize(effects)
        for (request in requests) {
            processEffect(request)
        }
    }
    // ...
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../guide/testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../guide/composing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../guide/testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../guide/composing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
